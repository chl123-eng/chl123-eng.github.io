{"title":"Vue.2.6源码分析之响应式数据原理","uid":"e0084657f452526ce5e427bc65b7869d","slug":"Vue.2.6源码分析之响应式数据原理","date":"2024-07-19T16:00:00.000Z","updated":"2024-07-10T08:03:54.277Z","comments":true,"path":"api/articles/Vue.2.6源码分析之响应式数据原理.json","keywords":"蔡惠霖的博客，前端开发，Vue，Node.js","cover":"https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/vue-01.jpg","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>响应式 是 Vue 最独特的特性之一。当修改实例的 data 的属性时，视图会进行更新。vue2 的数据劫持是利用 Object.defineProperty 的 getter 和 setter 来监听到属性的变化。</p>\n<h3 id=\"实现思路\"><a href=\"#实现思路\" class=\"headerlink\" title=\"实现思路\"></a>实现思路</h3><p>1、定义 observer 函数<br>2、判断监听的值,如果是对象，则创建一个 Observer 类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(typeof data != &#x27;object&#x27; || data == null)&#123;</span><br><span class=\"line\">       return data;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   return new Observer(data)</span><br></pre></td></tr></table></figure>\n\n<p>3、判断是对象还是数组</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(Array.isArray(value))</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"对象的数据劫持\"><a href=\"#对象的数据劫持\" class=\"headerlink\" title=\"对象的数据劫持\"></a>对象的数据劫持</h3><p>1、Observer 定义一个方法 walk,遍历对象的每个属性</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">walk(data)&#123;</span><br><span class=\"line\">    let keys = Object.keys(data);</span><br><span class=\"line\">    for(let i = 0; i &lt; keys.length; i++)&#123;</span><br><span class=\"line\">        let key = keys[i];</span><br><span class=\"line\">        let value = data[key];</span><br><span class=\"line\">        defineReactive(data,key,value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、定义 defineReactive，Object.defineProperty 对遍历的每个属性进行劫持</p>\n<p>tip:<br>1、初始化的数据中对象的属性依然是一个对象时，要进行深度劫持，即递归；<br>2、对某个对象的属性赋值为一个对象时，在 set 中，对新赋值的对象进行劫持</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function defineReactive(data,key,value)&#123;</span><br><span class=\"line\">    observer(value);//递归，劫持对象的某个对象属性</span><br><span class=\"line\">    Object.defineProperty(data,key,&#123;</span><br><span class=\"line\">        get()&#123;</span><br><span class=\"line\">            return value</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        set(newValue)&#123;</span><br><span class=\"line\">            if(newValue == value) return;</span><br><span class=\"line\">            observer(newValue);//如果赋值是一个对象，则要对对象进行遍历劫持</span><br><span class=\"line\">            value = newValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数组的数据劫持\"><a href=\"#数组的数据劫持\" class=\"headerlink\" title=\"数组的数据劫持\"></a>数组的数据劫持</h3><p>如果属性是一个数组，则通过重写 Array 的方法进行函数劫持</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(Array.isArray(value))&#123;</span><br><span class=\"line\">    value.__proto__ = ArrayMethods;</span><br><span class=\"line\"></span><br><span class=\"line\">    //如果是数组对象</span><br><span class=\"line\">    this.observeArray(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">observeArray(value)&#123;</span><br><span class=\"line\">    value.forEach(itemValue =&gt; &#123;</span><br><span class=\"line\">        observer(itemValue)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>arr.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//监听到data的属性是数组的时候重写Array的原型方法，即劫持函数</span><br><span class=\"line\"></span><br><span class=\"line\">//获取原来的数组方法</span><br><span class=\"line\">let oldArrayProtoMethods = Array.prototype;</span><br><span class=\"line\"></span><br><span class=\"line\">//继承: 现有的对象(oldArrayProtoMethods)来作为新创建对象(ArrayMethods)的原型</span><br><span class=\"line\">export let ArrayMethods = Object.create(oldArrayProtoMethods);</span><br><span class=\"line\"></span><br><span class=\"line\">//劫持</span><br><span class=\"line\">let methods = [</span><br><span class=\"line\">    &#x27;push&#x27;,</span><br><span class=\"line\">    &#x27;pop&#x27;,</span><br><span class=\"line\">    &#x27;unshift&#x27;,</span><br><span class=\"line\">    &#x27;splice&#x27;</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">methods.forEach(item =&gt; &#123;</span><br><span class=\"line\">    ArrayMethods[item] = function(...args)&#123;</span><br><span class=\"line\">        console.log(&#x27;劫持数组&#x27;);</span><br><span class=\"line\">        let result = oldArrayProtoMethods[item].apply(this,args)</span><br><span class=\"line\"></span><br><span class=\"line\">        //数组追加对象的情况</span><br><span class=\"line\"></span><br><span class=\"line\">        let inserted</span><br><span class=\"line\">        switch(item)&#123;</span><br><span class=\"line\">            case &#x27;push&#x27;:</span><br><span class=\"line\">            case &#x27;unshift&#x27;:</span><br><span class=\"line\">                inserted = args</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            case &#x27;splice&#x27;:</span><br><span class=\"line\">                inserted = args.splice(2);</span><br><span class=\"line\">                break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //this指向数组中新增的对象&#123;e:1&#125;,故有_ob_属性，指向Observer</span><br><span class=\"line\">        let ob = this._ob_;</span><br><span class=\"line\"></span><br><span class=\"line\">        if(inserted)&#123;</span><br><span class=\"line\">            ob.observeArray(inserted);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>tips:<br>1、对于一个对象数组，eg:[{a:1}], 遍历数组后，调用 observer 对对象进行劫持<br>2、数组中添加一个对象</p>\n","text":"前言响应式 是 Vue 最独特的特性之一。当修改实例的 data 的属性时，视图会进行更新。vue2 的数据劫持是利用 Object.definePropert...","permalink":"/post/Vue.2.6源码分析之响应式数据原理","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"Vue","slug":"Vue","count":4,"path":"api/categories/Vue.json"},{"name":"总结","slug":"Vue/总结","count":4,"path":"api/categories/Vue/总结.json"},{"name":"Vue源码","slug":"Vue/总结/Vue源码","count":4,"path":"api/categories/Vue/总结/Vue源码.json"}],"tags":[{"name":"Vue","slug":"Vue","count":5,"path":"api/tags/Vue.json"},{"name":"Vue源码","slug":"Vue源码","count":4,"path":"api/tags/Vue源码.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">实现思路</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81\"><span class=\"toc-text\">对象的数据劫持</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81\"><span class=\"toc-text\">数组的数据劫持</span></a></li></ol>","author":{"name":"May","slug":"blog-author","avatar":"https://chlblog.oss-cn-guangzhou.aliyuncs.com/logo.jpg","link":"/","description":"Love Music, love life","socials":{"github":"https://github.com/ShuHongXie","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"小程序分包","uid":"8cb2683bb6a5c8d0f688364471819883","slug":"小程序分包","date":"2024-05-10T07:08:26.000Z","updated":"2024-06-27T03:22:12.994Z","comments":true,"path":"api/articles/小程序分包.json","keywords":"蔡惠霖的博客，前端开发，Vue，Node.js","cover":[],"text":"前言微信小程序分包常用于代码量较大的小程序，发布时会受到大小限制 什么是分包分包指的是把一个完整的小程序项目，按照需求划分为不同的子包，在构建时打包成不同的分包...","permalink":"/post/小程序分包","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"总结","slug":"总结","count":2,"path":"api/categories/总结.json"}],"tags":[{"name":"小程序","slug":"小程序","count":1,"path":"api/tags/小程序.json"}],"author":{"name":"May","slug":"blog-author","avatar":"https://chlblog.oss-cn-guangzhou.aliyuncs.com/logo.jpg","link":"/","description":"Love Music, love life","socials":{"github":"https://github.com/ShuHongXie","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Vue-2-6源码分析之watch原理","uid":"0a161586c3aef7ad5ff8ec1ffa31ca64","slug":"Vue-2-6源码分析之watch原理","date":"2024-07-15T09:15:07.000Z","updated":"2024-07-16T01:53:02.102Z","comments":true,"path":"api/articles/Vue-2-6源码分析之watch原理.json","keywords":"蔡惠霖的博客，前端开发，Vue，Node.js","cover":"https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/vue-01.jpg","text":"Watcher的种类是什么Watcher的种类 渲染Watcher ：变量修改时，负责通知HTML里的重新渲染 computed Watcher ：变量修改时，...","permalink":"/post/Vue-2-6源码分析之watch原理","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"Vue","slug":"Vue","count":4,"path":"api/categories/Vue.json"},{"name":"总结","slug":"Vue/总结","count":4,"path":"api/categories/Vue/总结.json"},{"name":"Vue源码","slug":"Vue/总结/Vue源码","count":4,"path":"api/categories/Vue/总结/Vue源码.json"}],"tags":[{"name":"Vue","slug":"Vue","count":5,"path":"api/tags/Vue.json"},{"name":"Vue源码","slug":"Vue源码","count":4,"path":"api/tags/Vue源码.json"}],"author":{"name":"May","slug":"blog-author","avatar":"https://chlblog.oss-cn-guangzhou.aliyuncs.com/logo.jpg","link":"/","description":"Love Music, love life","socials":{"github":"https://github.com/ShuHongXie","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}