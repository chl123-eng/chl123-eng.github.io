{"title":"重复请求取消","uid":"c1c5f0f95038546d7bb9b5b686492430","slug":"重复请求取消","date":"2024-08-30T06:08:51.000Z","updated":"2024-08-30T06:22:28.241Z","comments":true,"path":"api/articles/重复请求取消.json","keywords":"蔡惠霖的博客，前端开发，Vue，Node.js","cover":"https://chlblog.oss-cn-guangzhou.aliyuncs.com/compress.jpg","content":"<h3 id=\"场景模拟\"><a href=\"#场景模拟\" class=\"headerlink\" title=\"场景模拟\"></a>场景模拟</h3><p>假设在一个电商网站中，用户在输入搜索关键字时，会触发搜索功能。如果用户输入过快，前一个搜索请求还未完成就发起了下一个，这时就需要取消前一个请求，确保只有最后一次请求被执行。</p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>首先，在请求拦截器中生成并维护请求数组。发起请求时，检查当前请求是否重复,如果是，则取消前一个请求。同时，在响应拦截器中清理完成的请求标识，保证请求映射表的准确性。</p>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import axios from &quot;axios&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// isCancel-取消标识 可以根据这个值判断请求是否被取消</span><br><span class=\"line\">const &#123; isCancel &#125; = axios</span><br><span class=\"line\">const cacheRequest = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 删除缓存队列中的请求</span><br><span class=\"line\">function abortCacheRequest(reqKey) &#123;</span><br><span class=\"line\">  if (cacheRequest[reqKey]) &#123;</span><br><span class=\"line\">    // 通过AbortController实例上的abort来终止请求</span><br><span class=\"line\">    cacheRequest[reqKey].abort()</span><br><span class=\"line\">    delete cacheRequest[reqKey]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 请求拦截函数</span><br><span class=\"line\">axios.interceptors.request.use(</span><br><span class=\"line\">  (config) =&gt; &#123;</span><br><span class=\"line\">    const &#123; url, method, isAbort= false &#125; = config</span><br><span class=\"line\">    if (isAbort) &#123;</span><br><span class=\"line\">        // 请求地址和请求方式组成唯一标识，将这个标识作为取消函数的key，保存到请求队列中</span><br><span class=\"line\">        const reqKey = `$&#123;url&#125;&amp;$&#123;method&#125;`</span><br><span class=\"line\">        // 如果config传了需要清除重复请求的isAbort，则如果存在重复请求，删除之前的请求</span><br><span class=\"line\">        abortCacheRequest(reqKey)</span><br><span class=\"line\">        // 将请求加入请求队列，通过AbortController来进行手动取消</span><br><span class=\"line\">        const controller = new AbortController()</span><br><span class=\"line\">        config.signal = controller.signal</span><br><span class=\"line\">        cacheRequest[reqKey] = controller</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return config;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  (err) =&gt; &#123;</span><br><span class=\"line\">    return Promise.reject(err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\">// 响应拦截函数</span><br><span class=\"line\">axios.interceptors.response.use(</span><br><span class=\"line\">  (res) =&gt; &#123;</span><br><span class=\"line\">    const &#123; url,method, isAbort = false &#125; = res.config</span><br><span class=\"line\">    if (isAbort) &#123;</span><br><span class=\"line\">      delete cacheRequest[`$&#123;url&#125;&amp;$&#123;method&#125;`]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return Promise.resolve(res);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  (error) =&gt; &#123;</span><br><span class=\"line\">    if (isCancel(error)) &#123;</span><br><span class=\"line\">      // 通过AbortController取消的请求不做任何处理</span><br><span class=\"line\">      return Promise.reject(&#123;</span><br><span class=\"line\">        message: &#x27;重复请求，已取消&#x27;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    if (error.response) &#123;</span><br><span class=\"line\">      return errorHandle(</span><br><span class=\"line\">        error.response.status,</span><br><span class=\"line\">        error.response.data.message || error.response.data.msg,</span><br><span class=\"line\">        error.response</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      // alert(&#x27;你已断开网络,请刷新页面&#x27;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">export default (url, data = &#123;&#125;, type = &quot;GET&quot;,isAbort) =&gt; &#123;</span><br><span class=\"line\">  type = type.toUpperCase();</span><br><span class=\"line\">  if (type == &quot;GET&quot;) &#123;</span><br><span class=\"line\">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">      axios</span><br><span class=\"line\">        .get(url, &#123;</span><br><span class=\"line\">          params: data,</span><br><span class=\"line\">          isAbort</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .then((response) =&gt; &#123;</span><br><span class=\"line\">          if(response)&#123;</span><br><span class=\"line\">            resolve(response &amp;&amp; response.data);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">         </span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .catch((err) =&gt; &#123;</span><br><span class=\"line\">          reject(err);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>","text":"场景模拟假设在一个电商网站中，用户在输入搜索关键字时，会触发搜索功能。如果用户输入过快，前一个搜索请求还未完成就发起了下一个，这时就需要取消前一个请求，确保只有...","permalink":"/post/重复请求取消","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"经验总结","slug":"经验总结","count":2,"path":"api/categories/经验总结.json"}],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9C%BA%E6%99%AF%E6%A8%A1%E6%8B%9F\"><span class=\"toc-text\">场景模拟</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">实现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">代码实现</span></a></li></ol>","author":{"name":"May","slug":"blog-author","avatar":"https://chlblog.oss-cn-guangzhou.aliyuncs.com/logo.jpg","link":"/","description":"Love Music, love life","socials":{"github":"https://github.com/ShuHongXie","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"如何缩小小程序主包大小","uid":"dc21ebec27b21dd15d905d44cdd109ba","slug":"如何缩小小程序主包大小","date":"2024-10-10T02:05:17.000Z","updated":"2024-10-10T02:40:32.585Z","comments":true,"path":"api/articles/如何缩小小程序主包大小.json","keywords":"蔡惠霖的博客，前端开发，Vue，Node.js","cover":"https://chlblog.oss-cn-guangzhou.aliyuncs.com/compress.jpg","text":"前言如果要将一个很大的app迁移到小程序，那么必然会面临主包太大导致上传失败的问题。下面将从各个方面去压缩主包： 方法一：线上图片小程序体积大是因为static...","permalink":"/post/如何缩小小程序主包大小","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"经验总结","slug":"经验总结","count":2,"path":"api/categories/经验总结.json"}],"tags":[],"author":{"name":"May","slug":"blog-author","avatar":"https://chlblog.oss-cn-guangzhou.aliyuncs.com/logo.jpg","link":"/","description":"Love Music, love life","socials":{"github":"https://github.com/ShuHongXie","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"canvas图片压缩上传","uid":"fc9692fb8852291ea0c5a4e4a14a397d","slug":"canvas图片压缩上传","date":"2024-08-28T03:05:04.000Z","updated":"2024-08-29T06:18:38.716Z","comments":true,"path":"api/articles/canvas图片压缩上传.json","keywords":"蔡惠霖的博客，前端开发，Vue，Node.js","cover":"https://chlblog.oss-cn-guangzhou.aliyuncs.com/compress.jpg","text":"前言uni-app实现将图片压缩后上传到服务器，实现方式：新建canvas画布，设置尺寸来实现压缩，同时显示了图片格式 代码实现1234567891011121...","permalink":"/post/canvas图片压缩上传","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"常用组件封装","slug":"常用组件封装","count":2,"path":"api/categories/常用组件封装.json"}],"tags":[],"author":{"name":"May","slug":"blog-author","avatar":"https://chlblog.oss-cn-guangzhou.aliyuncs.com/logo.jpg","link":"/","description":"Love Music, love life","socials":{"github":"https://github.com/ShuHongXie","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}