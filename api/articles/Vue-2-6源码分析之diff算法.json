{"title":"Vue-2-6源码分析之diff算法","uid":"6d3831836232ca9c37c73563d720e679","slug":"Vue-2-6源码分析之diff算法","date":"2024-07-24T07:45:20.000Z","updated":"2024-07-24T09:39:32.295Z","comments":true,"path":"api/articles/Vue-2-6源码分析之diff算法.json","keywords":"蔡惠霖的博客，前端开发，Vue，Node.js","cover":"https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/vue-01.jpg","content":"<h3 id=\"虚拟DOM算法\"><a href=\"#虚拟DOM算法\" class=\"headerlink\" title=\"虚拟DOM算法\"></a>虚拟DOM算法</h3><p> <span style=\"background-color: #fff5f5;color: #ff502c;\">虚拟DOM算法 &#x3D; 虚拟DOM + Diff算法</span></p>\n<p>  <span style=\"color: #036aca;\">虚拟DOM算法操作真实DOM，性能高于直接操作真实DOM</span></p>\n<h3 id=\"虚拟DOM\"><a href=\"#虚拟DOM\" class=\"headerlink\" title=\"虚拟DOM\"></a>虚拟DOM</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul id=&quot;list&quot;&gt;</span><br><span class=\"line\">    &lt;li class=&quot;item&quot;&gt;哈哈&lt;/li&gt;</span><br><span class=\"line\">    &lt;li class=&quot;item&quot;&gt;呵呵&lt;/li&gt;</span><br><span class=\"line\">    &lt;li class=&quot;item&quot;&gt;林三心哈哈哈哈哈&lt;/li&gt; // 修改</span><br><span class=\"line\">&lt;/ul&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>生成的新虚拟DOM为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let newVDOM = &#123; // 新虚拟DOM</span><br><span class=\"line\">    tagName: &#x27;ul&#x27;, // 标签名</span><br><span class=\"line\">    props: &#123; // 标签属性</span><br><span class=\"line\">        id: &#x27;list&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    children: [ // 标签子节点</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            tagName: &#x27;li&#x27;, props: &#123; class: &#x27;item&#x27; &#125;, children: [&#x27;哈哈&#x27;]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            tagName: &#x27;li&#x27;, props: &#123; class: &#x27;item&#x27; &#125;, children: [&#x27;呵呵&#x27;]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            tagName: &#x27;li&#x27;, props: &#123; class: &#x27;item&#x27; &#125;, children: [&#x27;林三心哈哈哈哈哈&#x27;]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Diff算法\"><a href=\"#Diff算法\" class=\"headerlink\" title=\"Diff算法\"></a>Diff算法</h3><p><span style=\"color: #036aca;\">概念：</span>对比两者是旧虚拟DOM和新虚拟DOM，对比出是哪个虚拟节点更改了，找出这个虚拟节点，并只更新这个虚拟节点所对应的真实节点，而不用更新其他数据没发生改变的节点，实现精准地更新真实DOM，进而提高效率。</p>\n<h4 id=\"Diff同层对比\"><a href=\"#Diff同层对比\" class=\"headerlink\" title=\"Diff同层对比\"></a>Diff同层对比</h4><p>新旧虚拟DOM对比的时候，Diff算法比较只会在同层级进行, 不会跨层级比较。 所以Diff算法是:<span style=\"color: #ff502c;\">深度优先算法</span>。</p>\n<div>\n<img src=\"https://chlblog.oss-cn-guangzhou.aliyuncs.com/diff1.png\" />\n</div>\n\n<h4 id=\"对比流程\"><a href=\"#对比流程\" class=\"headerlink\" title=\"对比流程\"></a>对比流程</h4><div>\n<img src=\"https://chlblog.oss-cn-guangzhou.aliyuncs.com/diff2.png\" />\n</div>\n\n<p><span style=\"color: #036aca;\">patch的核心原理代码</span></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function patch(oldVnode, newVnode) &#123;</span><br><span class=\"line\">  // 比较是否为一个类型的节点</span><br><span class=\"line\">  if (sameVnode(oldVnode, newVnode)) &#123;</span><br><span class=\"line\">    // 是：继续进行深层比较</span><br><span class=\"line\">    patchVnode(oldVnode, newVnode)</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    // 否</span><br><span class=\"line\">    const oldEl = oldVnode.el // 旧虚拟节点的真实DOM节点</span><br><span class=\"line\">    const parentEle = api.parentNode(oldEl) // 获取父节点</span><br><span class=\"line\">    createEle(newVnode) // 创建新虚拟节点对应的真实DOM节点</span><br><span class=\"line\">    if (parentEle !== null) &#123;</span><br><span class=\"line\">      api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) // 将新元素添加进父元素</span><br><span class=\"line\">      api.removeChild(parentEle, oldVnode.el)  // 移除以前的旧元素节点</span><br><span class=\"line\">      // 设置null，释放内存</span><br><span class=\"line\">      oldVnode = null</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return newVnode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function sameVnode(oldVnode, newVnode) &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    oldVnode.key === newVnode.key &amp;&amp; // key值是否一样</span><br><span class=\"line\">    oldVnode.tagName === newVnode.tagName &amp;&amp; // 标签名是否一样</span><br><span class=\"line\">    oldVnode.isComment === newVnode.isComment &amp;&amp; // 是否都为注释节点</span><br><span class=\"line\">    isDef(oldVnode.data) === isDef(newVnode.data) &amp;&amp; // 是否都定义了data</span><br><span class=\"line\">    sameInputType(oldVnode, newVnode) // 当标签为input时，type必须是否相同</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span style=\"color: #036aca;\">patchVnode方法</span></p>\n<div>\n<li>\n    找到对应的真实DOM，称为el\n</li>\n<li>\n    判断newVnode和oldVnode是否指向同一个对象，如果是，那么直接return\n</li>\n<li>\n    如果他们都有文本节点并且不相等，那么将el的文本节点设置为newVnode的文本节点。\n</li>\n<li>\n    如果oldVnode有子节点而newVnode没有，则删除el的子节点\n</li>\n<li>\n    如果oldVnode没有子节点而newVnode有，则将newVnode的子节点真实化之后添加到el\n</li>\n<li>\n    如果两者都有子节点，则执行updateChildren函数比较子节点\n</li>\n</div>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function patchVnode(oldVnode, newVnode) &#123;</span><br><span class=\"line\">  const el = newVnode.el = oldVnode.el // 获取真实DOM对象</span><br><span class=\"line\">  // 获取新旧虚拟节点的子节点数组</span><br><span class=\"line\">  const oldCh = oldVnode.children, newCh = newVnode.children</span><br><span class=\"line\">  // 如果新旧虚拟节点是同一个对象，则终止</span><br><span class=\"line\">  if (oldVnode === newVnode) return</span><br><span class=\"line\">  // 如果新旧虚拟节点是文本节点，且文本不一样</span><br><span class=\"line\">  if (oldVnode.text !== null &amp;&amp; newVnode.text !== null &amp;&amp; oldVnode.text !== newVnode.text) &#123;</span><br><span class=\"line\">    // 则直接将真实DOM中文本更新为新虚拟节点的文本</span><br><span class=\"line\">    api.setTextContent(el, newVnode.text)</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    // 否则</span><br><span class=\"line\"></span><br><span class=\"line\">    if (oldCh &amp;&amp; newCh &amp;&amp; oldCh !== newCh) &#123;</span><br><span class=\"line\">      // 新旧虚拟节点都有子节点，且子节点不一样</span><br><span class=\"line\"></span><br><span class=\"line\">      // 对比子节点，并更新</span><br><span class=\"line\">      updateChildren(el, oldCh, newCh)</span><br><span class=\"line\">    &#125; else if (newCh) &#123;</span><br><span class=\"line\">      // 新虚拟节点有子节点，旧虚拟节点没有</span><br><span class=\"line\"></span><br><span class=\"line\">      // 创建新虚拟节点的子节点，并更新到真实DOM上去</span><br><span class=\"line\">      createEle(newVnode)</span><br><span class=\"line\">    &#125; else if (oldCh) &#123;</span><br><span class=\"line\">      // 旧虚拟节点有子节点，新虚拟节点没有</span><br><span class=\"line\"></span><br><span class=\"line\">      //直接删除真实DOM里对应的子节点</span><br><span class=\"line\">      api.removeChild(el)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><span style=\"color: #036aca;\">updateChildren方法</span></p>\n<div>\n<li>\n    oldS 和 newS 使用sameVnode方法进行比较，sameVnode(oldS, newS)\n</li>\n<li>\n    oldS 和 newE 使用sameVnode方法进行比较，sameVnode(oldS, newE)\n</li>\n<li>\n   oldE 和 newS 使用sameVnode方法进行比较，sameVnode(oldE, newS)\n</li>\n<li>\n    oldE 和 newE 使用sameVnode方法进行比较，sameVnode(oldE, newE)\n</li>\n<li>\n    如果以上逻辑都匹配不到，再把所有旧子节点的 key 做一个映射到旧节点下标的 key -> index 表，然后用新 vnode 的 key 去找出在旧节点中可以复用的位置。\n</li>\n</div>\n\n<div>\n<img src=\"https://chlblog.oss-cn-guangzhou.aliyuncs.com/diff3.png\" />\n</div>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">oldS = a, oldE = c</span><br><span class=\"line\">newS = b, newE = a</span><br></pre></td></tr></table></figure>\n<p>oldS 和 newE 相等，需要把节点a移动到newE所对应的位置，也就是末尾，同时oldS++，newE–</p>\n<div>\n<img src=\"https://chlblog.oss-cn-guangzhou.aliyuncs.com/diff4.png\" />\n</div>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">oldS = b, oldE = c</span><br><span class=\"line\">newS = b, newE = e</span><br></pre></td></tr></table></figure>\n<p>oldS 和 newS相等，需要把节点b移动到newS所对应的位置，同时oldS++,newS++</p>\n<div>\n<img src=\"https://chlblog.oss-cn-guangzhou.aliyuncs.com/diff5.png\" />\n</div>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">oldS = c, oldE = c</span><br><span class=\"line\">newS = c, newE = e</span><br></pre></td></tr></table></figure>\n<p>oldS、oldE 和 newS相等，需要把节点c移动到newS所对应的位置，同时oldS++,newS++</p>\n<div>\n<img src=\"https://chlblog.oss-cn-guangzhou.aliyuncs.com/diff6.png\" />\n</div>\n\n<p>oldS &gt; oldE，则oldCh先遍历完成了，而newCh还没遍历完，说明newCh比oldCh多，所以需要将多出来的节点，插入到真实DOM上对应的位置上</p>\n<div>\n<img src=\"https://chlblog.oss-cn-guangzhou.aliyuncs.com/diff7.png\" />\n</div>\n\n<p><span style=\"color: #036aca;\">updateChildren函数</span></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function updateChildren方法(oldChildren,newChildren,parent)&#123;</span><br><span class=\"line\">    //创建双指针</span><br><span class=\"line\">    let oldStartIndex = 0</span><br><span class=\"line\">    let oldStartVnode = oldChildren[oldStartIndex]</span><br><span class=\"line\">    let oldEndIndex = oldChildren.length - 1</span><br><span class=\"line\">    let oldEndVnode = oldChildren[oldEndIndex]</span><br><span class=\"line\"></span><br><span class=\"line\">    let newStartIndex = 0</span><br><span class=\"line\">    let newStartVnode = newChildren[newStartIndex]</span><br><span class=\"line\">    let newEndIndex = newChildren.length - 1</span><br><span class=\"line\">    let newEndVnode = newChildren[newEndIndex]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    //创建旧元素的映射表</span><br><span class=\"line\">    function makeIndexBykey(child)&#123;</span><br><span class=\"line\">        let map = &#123;&#125;</span><br><span class=\"line\">        child.forEach((item,index) =&gt; &#123;</span><br><span class=\"line\">            if(item.key)&#123;</span><br><span class=\"line\">                map[item.key] = index;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        return map</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    let map = makeIndexBykey(oldChildren)</span><br><span class=\"line\">    //判断是否是同一元素</span><br><span class=\"line\">    function isSameVnode(oldContext,newContext)&#123;</span><br><span class=\"line\">        return (oldContext.tag === newContext.tag &amp;&amp; oldContext.key == newContext.key)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    while(oldStartIndex &lt;= oldEndIndex &amp;&amp; newStartIndex &lt;= newEndIndex)&#123;</span><br><span class=\"line\">        //判断头部是否是同一元素 1-4是交叉比对</span><br><span class=\"line\">        if(isSameVnode(oldStartVnode,newStartVnode))&#123;//从头部开始比</span><br><span class=\"line\">            //递归</span><br><span class=\"line\">            patch(oldStartVnode,newStartVnode)</span><br><span class=\"line\">            //移动指针</span><br><span class=\"line\">            oldStartVnode = oldChildren[++oldStartIndex]</span><br><span class=\"line\">            newStartVnode = newChildren[++newStartIndex]</span><br><span class=\"line\">        &#125;else if(isSameVnode(oldEndVnode,newEndVnode))&#123;//从尾部开始比</span><br><span class=\"line\">            patch(oldEndVnode,newEndVnode)</span><br><span class=\"line\">            //移动指针</span><br><span class=\"line\">            oldEndVnode = oldChildren[--oldEndIndex]</span><br><span class=\"line\">            newEndVnode = newChildren[--newEndIndex]</span><br><span class=\"line\">        &#125;else if(isSameVnode(oldStartVnode,newEndVnode))&#123;//旧前新后比</span><br><span class=\"line\">            patch(oldStartVnode,newEndVnode)</span><br><span class=\"line\">            //移动指针</span><br><span class=\"line\">            oldStartVnode = oldChildren[++oldStartIndex]</span><br><span class=\"line\">            newEndVnode = newChildren[--newEndIndex]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if(isSameVnode(oldEndVnode,newStartVnode))&#123;//旧后新前比</span><br><span class=\"line\">            patch(oldEndVnode,newStartVnode)</span><br><span class=\"line\">            //移动指针</span><br><span class=\"line\">            oldEndVnode = oldChildren[--oldEndIndex]</span><br><span class=\"line\">            newStartVnode = newChildren[++newStartIndex]</span><br><span class=\"line\">        &#125;else&#123;//儿子之间没有任何关系 暴力比对</span><br><span class=\"line\">            //1、创建旧元素映射表</span><br><span class=\"line\">            //2、从老中寻找新的元素 map:&#123;c:0,b:1,a:2&#125;</span><br><span class=\"line\">            let moveIndex = map[newStartVnode.key]</span><br><span class=\"line\">            if(moveIndex == undefined)&#123;</span><br><span class=\"line\">                parent.insertBefore(createEl(newStartVnode),oldStartVnode.el)</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                let moveVnode = oldChildren[moveIndex] // 旧元素中匹配到的元素</span><br><span class=\"line\">                oldChildren[moveIndex] = null //防止数组塌陷</span><br><span class=\"line\">                //插入</span><br><span class=\"line\">                parent.insertBefore(moveVnode.el,oldStartVnode.el)</span><br><span class=\"line\">                //有儿子的情况 递归</span><br><span class=\"line\">                patch(moveVnode,newStartVnode)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            //新的元素指针位移</span><br><span class=\"line\">            newStartVnode = newChildren[++newStartIndex]</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //添加多余的儿子</span><br><span class=\"line\">    if(newStartIndex &lt;= newEndIndex)&#123;</span><br><span class=\"line\">        for(let i = newStartIndex; i &lt; newEndIndex;i++)&#123;</span><br><span class=\"line\">            parent.appendChild(createEl(newChildren[i]))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //将老的多余的元素去掉</span><br><span class=\"line\">    if(oldStartIndex &lt;= oldEndIndex)&#123;</span><br><span class=\"line\">        for(let i = oldStartIndex; i &lt;= oldEndIndex; i++)&#123;</span><br><span class=\"line\">            let child = oldChildren[i]</span><br><span class=\"line\">            if(child != null)&#123;</span><br><span class=\"line\">                parent.removeChild(child.el)//删除元素</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","text":"虚拟DOM算法 虚拟DOM算法 = 虚拟DOM + Diff算法 虚拟DOM算法操作真实DOM，性能高于直接操作真实DOM 虚拟DOM123456<ul id=...","permalink":"/post/Vue-2-6源码分析之diff算法","photos":[],"count_time":{"symbolsCount":"7.4k","symbolsTime":"7 mins."},"categories":[{"name":"Vue","slug":"Vue","count":5,"path":"api/categories/Vue.json"},{"name":"总结","slug":"Vue/总结","count":5,"path":"api/categories/Vue/总结.json"},{"name":"Vue源码","slug":"Vue/总结/Vue源码","count":5,"path":"api/categories/Vue/总结/Vue源码.json"}],"tags":[{"name":"Vue","slug":"Vue","count":6,"path":"api/tags/Vue.json"},{"name":"Vue源码","slug":"Vue源码","count":5,"path":"api/tags/Vue源码.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9FDOM%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">虚拟DOM算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9FDOM\"><span class=\"toc-text\">虚拟DOM</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Diff%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">Diff算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Diff%E5%90%8C%E5%B1%82%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">Diff同层对比</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E6%AF%94%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">对比流程</span></a></li></ol></li></ol>","author":{"name":"May","slug":"blog-author","avatar":"https://chlblog.oss-cn-guangzhou.aliyuncs.com/logo.jpg","link":"/","description":"Love Music, love life","socials":{"github":"https://github.com/ShuHongXie","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"小程序分包","uid":"8cb2683bb6a5c8d0f688364471819883","slug":"小程序分包","date":"2024-05-10T07:08:26.000Z","updated":"2024-06-27T03:22:12.994Z","comments":true,"path":"api/articles/小程序分包.json","keywords":"蔡惠霖的博客，前端开发，Vue，Node.js","cover":[],"text":"前言微信小程序分包常用于代码量较大的小程序，发布时会受到大小限制 什么是分包分包指的是把一个完整的小程序项目，按照需求划分为不同的子包，在构建时打包成不同的分包...","permalink":"/post/小程序分包","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"总结","slug":"总结","count":2,"path":"api/categories/总结.json"}],"tags":[{"name":"小程序","slug":"小程序","count":1,"path":"api/tags/小程序.json"}],"author":{"name":"May","slug":"blog-author","avatar":"https://chlblog.oss-cn-guangzhou.aliyuncs.com/logo.jpg","link":"/","description":"Love Music, love life","socials":{"github":"https://github.com/ShuHongXie","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Vue.2.6源码分析之响应式数据原理","uid":"e0084657f452526ce5e427bc65b7869d","slug":"Vue.2.6源码分析之响应式数据原理","date":"2024-07-19T16:00:00.000Z","updated":"2024-07-10T08:03:54.277Z","comments":true,"path":"api/articles/Vue.2.6源码分析之响应式数据原理.json","keywords":"蔡惠霖的博客，前端开发，Vue，Node.js","cover":"https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/vue-01.jpg","text":"前言响应式 是 Vue 最独特的特性之一。当修改实例的 data 的属性时，视图会进行更新。vue2 的数据劫持是利用 Object.definePropert...","permalink":"/post/Vue.2.6源码分析之响应式数据原理","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"Vue","slug":"Vue","count":5,"path":"api/categories/Vue.json"},{"name":"总结","slug":"Vue/总结","count":5,"path":"api/categories/Vue/总结.json"},{"name":"Vue源码","slug":"Vue/总结/Vue源码","count":5,"path":"api/categories/Vue/总结/Vue源码.json"}],"tags":[{"name":"Vue","slug":"Vue","count":6,"path":"api/tags/Vue.json"},{"name":"Vue源码","slug":"Vue源码","count":5,"path":"api/tags/Vue源码.json"}],"author":{"name":"May","slug":"blog-author","avatar":"https://chlblog.oss-cn-guangzhou.aliyuncs.com/logo.jpg","link":"/","description":"Love Music, love life","socials":{"github":"https://github.com/ShuHongXie","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}