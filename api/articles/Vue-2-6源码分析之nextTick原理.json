{"title":"Vue.2.6源码分析之nextTick原理","uid":"f6b138999f3f27abf400958100e01e94","slug":"Vue-2-6源码分析之nextTick原理","date":"2024-07-10T08:03:25.000Z","updated":"2024-07-10T08:39:01.017Z","comments":true,"path":"api/articles/Vue-2-6源码分析之nextTick原理.json","keywords":"蔡惠霖的博客，前端开发，Vue，Node.js","cover":"https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/vue-01.jpg","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>Vue.js 中的 $nextTick 函数是一个非常重要的 API，它用于延迟回调的执行直到下次 DOM 更新循环之后。简单来说，$nextTick 会在 DOM 完全更新后执行其回调函数。这是 Vue.js 异步更新队列的一个具体应用。</p>\n<h3 id=\"源码实现\"><a href=\"#源码实现\" class=\"headerlink\" title=\"源码实现\"></a>源码实现</h3><h5 id=\"watcher监听数据\"><a href=\"#watcher监听数据\" class=\"headerlink\" title=\"watcher监听数据\"></a>watcher监听数据</h5><p>实现： 数据更新多次，vm._update(vm._render())只执行一次，即DOM只更新一次</p>\n<p>watcher.js文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class watcher &#123;</span><br><span class=\"line\">    constructor(vm, updateComponent,cb,options)&#123;</span><br><span class=\"line\">        .....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    run()&#123;</span><br><span class=\"line\">        this.get()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    get()&#123;</span><br><span class=\"line\">        this.getter()//外部传进来的vm._update(vm._render())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //更新</span><br><span class=\"line\">    update()&#123;</span><br><span class=\"line\">        queueWatcher(this)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let queue = [];//将需要批量更新的watcher存放到一个队列中</span><br><span class=\"line\">let has = &#123;&#125;;</span><br><span class=\"line\">let pending = false</span><br><span class=\"line\"></span><br><span class=\"line\">function flushWatcher()&#123;</span><br><span class=\"line\">    queue.forEach(item =&gt; &#123;item.run()&#125;)</span><br><span class=\"line\">    queue = [];</span><br><span class=\"line\">    has = &#123;&#125;</span><br><span class=\"line\">    pending = false</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function queueWatcher(watcher)&#123;</span><br><span class=\"line\">    let id = watcher.id //每个组件共用同一个watcher</span><br><span class=\"line\">    if(!has[id])&#123;//去重</span><br><span class=\"line\">        queue.push(watcher);</span><br><span class=\"line\">        has[id] = true;</span><br><span class=\"line\">        //防抖</span><br><span class=\"line\">        if(!pending)&#123;</span><br><span class=\"line\">            nextTick(flushWatcher) //相当于定时器,异步</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pending = true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"将操作放入异步队列中，进行同步执行\"><a href=\"#将操作放入异步队列中，进行同步执行\" class=\"headerlink\" title=\"将操作放入异步队列中，进行同步执行\"></a>将操作放入异步队列中，进行同步执行</h5><p>nextTick.js文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let callBack = [] //列队：1、是vue自己的nextTick, 2、$nextTick回调函数</span><br><span class=\"line\">let pending = false</span><br><span class=\"line\"></span><br><span class=\"line\">function flush()&#123;</span><br><span class=\"line\">    callBack.forEach(cb =&gt; &#123;</span><br><span class=\"line\">        cb();</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    pending = false</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let timerFunc</span><br><span class=\"line\">//处理兼容问题</span><br><span class=\"line\">if(Promise)&#123;</span><br><span class=\"line\">    timerFunc = () =&gt; &#123;</span><br><span class=\"line\">        Promise.resolve().then(flush)//使所有函数同步操作</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;else if(MutationObserver)&#123;//h5异步方法，监听dom变化，监控完毕后进行异步更新</span><br><span class=\"line\">    let observe = new MutationObserver(flush)</span><br><span class=\"line\">    let texNode = document.createTextNode(1)</span><br><span class=\"line\">    observe.observe(texNode,&#123;characterData: true&#125;);</span><br><span class=\"line\">    timerFunc = () =&gt;&#123;</span><br><span class=\"line\">        texNode.textContent = 2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;else if(setImmediate)&#123;//ie</span><br><span class=\"line\">    timerFunc = () =&gt; &#123;</span><br><span class=\"line\">        setImmediate(flush)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export function nextTick(cb)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    callBack.push(cb);</span><br><span class=\"line\">    if(!pending)&#123;</span><br><span class=\"line\">        timerFunc();</span><br><span class=\"line\">        pending = true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"定义-nextTick-API\"><a href=\"#定义-nextTick-API\" class=\"headerlink\" title=\"定义 $nextTick API\"></a>定义 $nextTick API</h5><p>initState.js，初始化定义一个 $nextTick API，将回调函数放入 $nextTick 中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export function stateMixin(vm)&#123;</span><br><span class=\"line\">    vm.prototype.$nextTick = function(cb) &#123;</span><br><span class=\"line\">        nextTick(cb)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"nextTick的使用场景\"><a href=\"#nextTick的使用场景\" class=\"headerlink\" title=\"$nextTick的使用场景\"></a>$nextTick的使用场景</h3><div>\n  <ul>\n    <li>\n        数据变化后立即获取 DOM 元素：例如，你可能需要在数据变化后立即获取 DOM 元素的尺寸或属性。\n    </li>\n    <li>\n        父子组件通信：在某些情况下，子组件需要在父组件更新后执行某些操作。\n    </li>\n  </ul>\n</div>","text":"前言Vue.js 中的 $nextTick 函数是一个非常重要的 API，它用于延迟回调的执行直到下次 DOM 更新循环之后。简单来说，$nextTick 会在...","permalink":"/post/Vue-2-6源码分析之nextTick原理","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"Vue","slug":"Vue","count":4,"path":"api/categories/Vue.json"},{"name":"总结","slug":"Vue/总结","count":4,"path":"api/categories/Vue/总结.json"},{"name":"Vue源码","slug":"Vue/总结/Vue源码","count":4,"path":"api/categories/Vue/总结/Vue源码.json"}],"tags":[{"name":"Vue","slug":"Vue","count":5,"path":"api/tags/Vue.json"},{"name":"Vue源码","slug":"Vue源码","count":4,"path":"api/tags/Vue源码.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">源码实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#watcher%E7%9B%91%E5%90%AC%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">watcher监听数据</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%B0%86%E6%93%8D%E4%BD%9C%E6%94%BE%E5%85%A5%E5%BC%82%E6%AD%A5%E9%98%9F%E5%88%97%E4%B8%AD%EF%BC%8C%E8%BF%9B%E8%A1%8C%E5%90%8C%E6%AD%A5%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">将操作放入异步队列中，进行同步执行</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89-nextTick-API\"><span class=\"toc-text\">定义 $nextTick API</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#nextTick%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">$nextTick的使用场景</span></a></li></ol>","author":{"name":"May","slug":"blog-author","avatar":"https://chlblog.oss-cn-guangzhou.aliyuncs.com/logo.jpg","link":"/","description":"Love Music, love life","socials":{"github":"https://github.com/ShuHongXie","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Vue-2-6源码分析之watcher原理","uid":"8af7d3fa7270a00dfbd22764626362d5","slug":"Vue-2-6源码分析之watcher原理-1","date":"2024-07-15T09:15:07.000Z","updated":"2024-07-16T01:58:57.406Z","comments":true,"path":"api/articles/Vue-2-6源码分析之watcher原理-1.json","keywords":"蔡惠霖的博客，前端开发，Vue，Node.js","cover":"https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/vue-01.jpg","text":"Watcher的种类是什么Watcher的种类 渲染Watcher ：变量修改时，负责通知HTML里的重新渲染 computed Watcher ：变量修改时，...","permalink":"/post/Vue-2-6源码分析之watcher原理-1","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"Vue","slug":"Vue","count":4,"path":"api/categories/Vue.json"},{"name":"总结","slug":"Vue/总结","count":4,"path":"api/categories/Vue/总结.json"},{"name":"Vue源码","slug":"Vue/总结/Vue源码","count":4,"path":"api/categories/Vue/总结/Vue源码.json"}],"tags":[{"name":"Vue","slug":"Vue","count":5,"path":"api/tags/Vue.json"},{"name":"Vue源码","slug":"Vue源码","count":4,"path":"api/tags/Vue源码.json"}],"author":{"name":"May","slug":"blog-author","avatar":"https://chlblog.oss-cn-guangzhou.aliyuncs.com/logo.jpg","link":"/","description":"Love Music, love life","socials":{"github":"https://github.com/ShuHongXie","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Vue-2-6源码分析之初次渲染及生命周期","uid":"b1597152b0a9a80173a513e01c3e8d7a","slug":"Vue-2-6源码分析之初次渲染及生命周期","date":"2024-06-27T03:50:12.000Z","updated":"2024-07-10T08:03:59.014Z","comments":true,"path":"api/articles/Vue-2-6源码分析之初次渲染及生命周期.json","keywords":"蔡惠霖的博客，前端开发，Vue，Node.js","cover":"https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/vue-01.jpg","text":" 渲染流程： 依次判断是否有render、template； 在没有template且存在el,就直接拿el.outerHTML； 有template且存在el...","permalink":"/post/Vue-2-6源码分析之初次渲染及生命周期","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"Vue","slug":"Vue","count":4,"path":"api/categories/Vue.json"},{"name":"总结","slug":"Vue/总结","count":4,"path":"api/categories/Vue/总结.json"},{"name":"Vue源码","slug":"Vue/总结/Vue源码","count":4,"path":"api/categories/Vue/总结/Vue源码.json"}],"tags":[{"name":"Vue","slug":"Vue","count":5,"path":"api/tags/Vue.json"},{"name":"Vue源码","slug":"Vue源码","count":4,"path":"api/tags/Vue源码.json"}],"author":{"name":"May","slug":"blog-author","avatar":"https://chlblog.oss-cn-guangzhou.aliyuncs.com/logo.jpg","link":"/","description":"Love Music, love life","socials":{"github":"https://github.com/ShuHongXie","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}