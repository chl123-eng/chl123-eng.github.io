{"title":"HTTP缓存机制记录","uid":"977046a105528b08c6104c9e8e95e023","slug":"HTTP缓存机制记录","date":"2019-12-03T16:00:00.000Z","updated":"2024-06-07T03:20:18.000Z","comments":true,"path":"api/articles/HTTP缓存机制记录.json","keywords":"蔡惠霖的博客，前端开发，Vue，Node.js","cover":"https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/http01.png","content":"<p>http 缓存机制很容易就忘记了 这里大概记录一下</p>\n<h2 id=\"简单概括\"><a href=\"#简单概括\" class=\"headerlink\" title=\"简单概括\"></a>简单概括</h2><p>http 缓存分为强缓存(Cache-Control &gt; Expires),协商缓存(Etag &#x2F; If-None-Match &gt; Last-Modified &#x2F; If-Modified-Since)强缓存和协商缓存的区别&gt; 强缓存命中的情况下不和服务器做交互，协商缓存不管有没有命中都会和服务器做交互</p>\n<h2 id=\"第一次请求\"><a href=\"#第一次请求\" class=\"headerlink\" title=\"第一次请求\"></a>第一次请求</h2><ol>\n<li>浏览器发起 http 请求到服务器。</li>\n<li>http 请求通过浏览器缓存，浏览器缓存没有发现该请求的缓存标识和缓存结果，会直接放行，让 http 请求直接请求到服务器。</li>\n<li>服务器返回请求结果和缓存规则给浏览器</li>\n<li>浏览器将请求结果和缓存标识存入浏览器缓存中，作为下一次请求的标识</li>\n</ol>\n<h2 id=\"第二次请求命中强缓存的情况\"><a href=\"#第二次请求命中强缓存的情况\" class=\"headerlink\" title=\"第二次请求命中强缓存的情况\"></a>第二次请求命中强缓存的情况</h2><ul>\n<li>Expires 该字段作为缓存标志， 如果客户端的时间小于 Expires 的值时，就直接使用缓存结果，但是这只是存在于 HTTP&#x2F;1.0 中，现今大部分已经被 Cache-Control 所替代</li>\n<li>Cache-Control HTTP1.1 所使用的标识，该字段有以下几种属性</li>\n<li>public：所有内容都将被缓存（客户端和代理服务器都可缓存）</li>\n<li>private：所有内容只有客户端可以缓存，Cache-Control 的默认取值</li>\n<li>no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li>\n<li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li>\n<li>max-age&#x3D;xxx (xxx is numeric)：缓存内容将在 xxx 秒后失效</li>\n</ul>\n<h2 id=\"第二次请求\"><a href=\"#第二次请求\" class=\"headerlink\" title=\"第二次请求\"></a>第二次请求</h2><ul>\n<li>强缓存未命中，协商缓存命中的情况当协商缓存命中时，服务器返回 304 状态码表示该资源没有更新协商缓存字段有 Last-Modified &#x2F; If-Modified-Since 和 Etag &#x2F; If-None-Match，其中 Etag &#x2F; If-None-Match 的优先级比 Last-Modified &#x2F; If-Modified-Since 高。</li>\n<li>If-None-Match&#x2F;Etag &#x3D;&gt; 客户端再次发起该请求时，携带上次请求返回的唯一标识 Etag 值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有 If-None-Match，则会根据 If-None-Match 的字段值与该资源在服务器的 Etag 值做对比，一致则返回 304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，返回 200</li>\n<li>Last-Modified&#x2F;If-Modified-Since &#x3D;&gt; 则是客户端再次发起该请求时，携带上次请求返回的 Last-Modified 值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有 If-Modified-Since 字段，则会根据 If-Modified-Since 的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于 If-Modified-Since 的字段值，则重新返回资源，状态码为 200；否则则返回 304，代表资源无更新，可继续使用缓存文件</li>\n</ul>\n","text":"http 缓存机制很容易就忘记了 这里大概记录一下 简单概括http 缓存分为强缓存(Cache-Control > Expires),协商缓存(Etag / ...","permalink":"/post/HTTP缓存机制记录","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"http","slug":"http","count":1,"path":"api/categories/http.json"},{"name":"总结","slug":"http/总结","count":1,"path":"api/categories/http/总结.json"}],"tags":[{"name":"http","slug":"http","count":2,"path":"api/tags/http.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8D%95%E6%A6%82%E6%8B%AC\"><span class=\"toc-text\">简单概括</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AF%B7%E6%B1%82\"><span class=\"toc-text\">第一次请求</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%AF%B7%E6%B1%82%E5%91%BD%E4%B8%AD%E5%BC%BA%E7%BC%93%E5%AD%98%E7%9A%84%E6%83%85%E5%86%B5\"><span class=\"toc-text\">第二次请求命中强缓存的情况</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%AF%B7%E6%B1%82\"><span class=\"toc-text\">第二次请求</span></a></li></ol>","author":{"name":"May","slug":"blog-author","avatar":"https://chlblog.oss-cn-guangzhou.aliyuncs.com/logo.jpg","link":"/","description":"Love Music, love life","socials":{"github":"https://github.com/ShuHongXie","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"服务器之正向代理和反向代理","uid":"d02145c722134b6141381c5add87923b","slug":"服务器之正向代理和反向代理","date":"2021-07-27T16:00:00.000Z","updated":"2024-06-07T03:20:18.000Z","comments":true,"path":"api/articles/服务器之正向代理和反向代理.json","keywords":"蔡惠霖的博客，前端开发，Vue，Node.js","cover":"https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/http01.png","text":"最近公司商家入驻准备上线，和运维在服务器代理这边折腾了不少时间，现在重新归纳一下正向代理和反向代理的相关概念和区别 正向代理简述：正向代理服务器作接受来自客户端...","permalink":"/post/服务器之正向代理和反向代理","photos":[],"count_time":{"symbolsCount":908,"symbolsTime":"1 mins."},"categories":[{"name":"总结","slug":"总结","count":2,"path":"api/categories/总结.json"}],"tags":[{"name":"http","slug":"http","count":2,"path":"api/tags/http.json"}],"author":{"name":"May","slug":"blog-author","avatar":"https://chlblog.oss-cn-guangzhou.aliyuncs.com/logo.jpg","link":"/","description":"Love Music, love life","socials":{"github":"https://github.com/ShuHongXie","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"CSS多行溢出处理","uid":"c56ee70c55fbd1ff18b7573952b52a52","slug":"CSS多行溢出处理","date":"2019-10-02T16:00:00.000Z","updated":"2024-06-07T03:20:18.000Z","comments":true,"path":"api/articles/CSS多行溢出处理.json","keywords":"蔡惠霖的博客，前端开发，Vue，Node.js","cover":null,"text":"CSS多行溢出处理...","permalink":"/post/CSS多行溢出处理","photos":[],"count_time":{"symbolsCount":248,"symbolsTime":"1 mins."},"categories":[{"name":"CSS样式","slug":"CSS样式","count":1,"path":"api/categories/CSS样式.json"}],"tags":[{"name":"CSS","slug":"CSS","count":1,"path":"api/tags/CSS.json"},{"name":"SCSS","slug":"SCSS","count":1,"path":"api/tags/SCSS.json"}],"author":{"name":"May","slug":"blog-author","avatar":"https://chlblog.oss-cn-guangzhou.aliyuncs.com/logo.jpg","link":"/","description":"Love Music, love life","socials":{"github":"https://github.com/ShuHongXie","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}