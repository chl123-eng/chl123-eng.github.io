[{"id":"e0084657f452526ce5e427bc65b7869d","title":"Vue.2.6源码分析之响应式数据原理","content":"前言响应式 是 Vue 最独特的特性之一。当修改实例的 data 的属性时，视图会进行更新。vue2 的数据劫持是利用 Object.defineProperty 的 getter 和 setter 来监听到属性的变化。\n实现思路1、定义 observer 函数2、判断监听的值,如果是对象，则创建一个 Observer 类\n12345if(typeof data != &#x27;object&#x27; || data == null)&#123;       return data;   &#125;   return new Observer(data)\n\n3、判断是对象还是数组\n1if(Array.isArray(value))\n\n对象的数据劫持1、Observer 定义一个方法 walk,遍历对象的每个属性\n12345678walk(data)&#123;    let keys = Object.keys(data);    for(let i = 0; i &lt; keys.length; i++)&#123;        let key = keys[i];        let value = data[key];        defineReactive(data,key,value);    &#125;&#125;\n\n2、定义 defineReactive，Object.defineProperty 对遍历的每个属性进行劫持\ntip:1、初始化的数据中对象的属性依然是一个对象时，要进行深度劫持，即递归；2、对某个对象的属性赋值为一个对象时，在 set 中，对新赋值的对象进行劫持\n12345678910111213function defineReactive(data,key,value)&#123;    observer(value);//递归，劫持对象的某个对象属性    Object.defineProperty(data,key,&#123;        get()&#123;            return value        &#125;,        set(newValue)&#123;            if(newValue == value) return;            observer(newValue);//如果赋值是一个对象，则要对对象进行遍历劫持            value = newValue;        &#125;    &#125;)&#125;\n\n数组的数据劫持如果属性是一个数组，则通过重写 Array 的方法进行函数劫持\n12345678910111213if(Array.isArray(value))&#123;    value.__proto__ = ArrayMethods;    //如果是数组对象    this.observeArray(value);&#125;observeArray(value)&#123;    value.forEach(itemValue =&gt; &#123;        observer(itemValue)    &#125;)&#125;\n\narr.js\n12345678910111213141516171819202122232425262728293031323334353637383940414243//监听到data的属性是数组的时候重写Array的原型方法，即劫持函数//获取原来的数组方法let oldArrayProtoMethods = Array.prototype;//继承: 现有的对象(oldArrayProtoMethods)来作为新创建对象(ArrayMethods)的原型export let ArrayMethods = Object.create(oldArrayProtoMethods);//劫持let methods = [    &#x27;push&#x27;,    &#x27;pop&#x27;,    &#x27;unshift&#x27;,    &#x27;splice&#x27;]methods.forEach(item =&gt; &#123;    ArrayMethods[item] = function(...args)&#123;        console.log(&#x27;劫持数组&#x27;);        let result = oldArrayProtoMethods[item].apply(this,args)        //数组追加对象的情况        let inserted        switch(item)&#123;            case &#x27;push&#x27;:            case &#x27;unshift&#x27;:                inserted = args                break;            case &#x27;splice&#x27;:                inserted = args.splice(2);                break;        &#125;        //this指向数组中新增的对象&#123;e:1&#125;,故有_ob_属性，指向Observer        let ob = this._ob_;        if(inserted)&#123;            ob.observeArray(inserted);        &#125;        return result    &#125;&#125;)\n\ntips:1、对于一个对象数组，eg:[{a:1}], 遍历数组后，调用 observer 对对象进行劫持2、数组中添加一个对象\n","slug":"Vue.2.6源码分析之响应式数据原理","date":"2024-07-19T16:00:00.000Z","categories_index":"Vue,总结,Vue源码","tags_index":"Vue,Vue源码","author_index":"May"},{"id":"8af7d3fa7270a00dfbd22764626362d5","title":"Vue-2-6源码分析之watcher原理","content":"Watcher的种类是什么Watcher的种类\n  \n    \n      渲染Watcher ：变量修改时，负责通知HTML里的重新渲染\n    \n    \n       computed Watcher ：变量修改时，负责通知computed里依赖此变量的computed属性变量的修改\n    \n     \n       watch Watcher ：变量修改时，负责通知watch属性里所对应的变量函数的执行\n    \n  \n\n\n\n实现数据响应式\n任何类型的Watcher都是基于数据响应式的，也就是说，要想实现Watcher，就需要先实现数据响应式，而数据响应式的原理就是通过Object.defineProperty去劫持变量的get和set属性。\n请移步[Vue.2.6源码分析之响应式数据原理]。\n\n\n什么是Dep？1234567891011121314151617181920// 例子代码，与本章代码无关&lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;data() &#123;        return &#123;            name: &#x27;林三心&#x27;        &#125;    &#125;,    computed: &#123;        info () &#123;            return this.name        &#125;    &#125;,    watch: &#123;        name(newVal) &#123;            console.log(newVal)        &#125;    &#125;\n这里name变量被三个地方所依赖，三个地方代表了三种Watcher，那么name会直接自己管这三个Watcher吗？答案是不会的，name会实例一个Dep，来帮自己管这几个Wacther，类似于管家，当name更改的时候，会通知dep，而dep则会带着主人的命令去通知这些Wacther去完成自己该做的事\n\nWatcher为何也要反过来收集Dep？上面说到了，dep是name的管家，他的职责是：name更新时，dep会带着主人的命令去通知subs里的Watcher去做该做的事，那么，dep收集Watcher很合理。那为什么watcher也需要反过来收集dep呢？这是因为computed属性里的变量没有自己的dep，也就是他没有自己的管家，看以下例子：\n\n这里先说一个知识点：如果html里不依赖name这个变量，那么无论name再怎么变，他都不会主动去刷新视图，因为html没引用他（说专业点就是：name的dep里没有渲染Watcher），注意，这里说的是不会主动，但这并不代表他不会被动去更新。什么情况下他会被动去更新呢？那就是computed有依赖他的属性变量。\n\n\n\n12345678910// 例子代码，与本章代码无关&lt;div&gt;&#123;&#123;person&#125;&#125;&lt;/div&gt;computed: &#123;    person &#123;        return `名称：$&#123;this.name&#125;`        &#125;    &#125;\n这里的person事依赖于name的，但是person是没有自己的dep的（因为他是computed属性变量），而name是有的。好了，继续看，请注意，此例子html里只有person的引用没有name的引用，所以name一改变，按理说虽然person跟着变了，但是html不会重新渲染，因为name虽然有dep，有更新视图的能力，但是奈何人家html不引用他啊！person想要自己去更新视图，但他却没这个能力啊，毕竟他没有dep这个管家！这个时候computed Watcher里收集的name的dep就派上用场了，可以借助这些dep去更新视图，达到更新html里的person的效果。具体会在下面computed里实现。\nWatcher的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import &#123; nextTick &#125; from &quot;../utils/nextTick&quot;;import &#123; popTarget, pushTarget &#125; from &quot;./dep&quot;;let id = 0class watcher &#123;    constructor(vm, exprOrfn,cb,options)&#123;        this.vm = vm;        this.exprOrfn = exprOrfn        this.cb = cb        this.options = options        this.id = id++        this.user = !!options.user        this.deps = [] //watcher存放dep        this.depsId = new Set()        if(typeof exprOrfn === &quot;function&quot;)&#123;            this.getter = exprOrfn        &#125;else&#123;//字符串变成函数            this.getter = function()&#123;//属性c.c.c                let path = exprOrfn.split(&#x27;.&#x27;);                let obj = vm;                for(let i = 0; i &lt; path.length; i++)&#123;                    obj = obj[path[i]]                &#125;                return obj;            &#125;        &#125;                //第一次渲染页面        this.value = this.get(); //获取watch旧值    &#125;    addDep(dep)&#123;        //1、去重        let id = dep.id        if(!this.depsId.has(id))&#123;            this.deps.push(dep)            this.depsId.add(id)            dep.addSub(this)        &#125;    &#125;    //更新数据    run()&#123;        let value = this.get() //watch新值        this.oldValue  = this.value        this.value = value        if(this.user)&#123;            this.cb.call(this.vm,value,this.oldValue);        &#125;    &#125;    get()&#123;        pushTarget(this);        const value = this.getter()//初次更新获取到原始的值        popTarget();        return value        // queueWatcher(this)    &#125;    //更新    update()&#123;        //实现：不要数据更新一次就调用一次        //方式：缓存        // this.getter()        queueWatcher(this)    &#125;&#125;let queue = [];//将需要批量更新的watcher存放到一个队列中let has = &#123;&#125;;let pending = falsefunction flushWatcher()&#123;    queue.forEach(item =&gt; &#123;item.run(),item.cb()&#125;)    queue = [];    has = &#123;&#125;    pending = false&#125;function queueWatcher(watcher)&#123;    let id = watcher.id //每个组件共用同一个watcher    if(!has[id])&#123;//去重        queue.push(watcher);        has[id] = true;        //防抖        if(!pending)&#123;            nextTick(flushWatcher) //相当于定时器,异步        &#125;                pending = true    &#125;&#125;export default watcher\n\n渲染Watcher：初始化渲染数据123456789101112  //lifecycle.js  export function mountComponent(vm,el)&#123;    //1、vm.render将render函数变成vnode    //2、vm._update将vnode变成真实dom    // vm._update(vm._render())    let updateComponent = () =&gt; &#123;        vm._update(vm._render())    &#125;    new watcher(vm,updateComponent, ()=&gt;&#123;    &#125;, true);&#125;\n\nwatch Watcher: 更新数据12345678//initState.js//watch Watcher关键：user: truevm.prototype.$watch = function(Vue,exprOfn,handler,options) &#123;    let watcher = new Watcher(Vue, exprOfn, handler, &#123;...options,user:true&#125;);    if(options.immediate)&#123;        handler.call(vm);    &#125;&#125;","slug":"Vue-2-6源码分析之watcher原理","date":"2024-07-15T09:15:07.000Z","categories_index":"Vue,总结,Vue源码","tags_index":"Vue,Vue源码","author_index":"May"},{"id":"f6b138999f3f27abf400958100e01e94","title":"Vue.2.6源码分析之nextTick原理","content":"前言Vue.js 中的 $nextTick 函数是一个非常重要的 API，它用于延迟回调的执行直到下次 DOM 更新循环之后。简单来说，$nextTick 会在 DOM 完全更新后执行其回调函数。这是 Vue.js 异步更新队列的一个具体应用。\n源码实现watcher监听数据实现： 数据更新多次，vm._update(vm._render())只执行一次，即DOM只更新一次\nwatcher.js文件\n1234567891011121314151617181920212223242526272829303132333435363738class watcher &#123;    constructor(vm, updateComponent,cb,options)&#123;        .....    &#125;    run()&#123;        this.get()    &#125;    get()&#123;        this.getter()//外部传进来的vm._update(vm._render())    &#125;    //更新    update()&#123;        queueWatcher(this)    &#125;&#125;let queue = [];//将需要批量更新的watcher存放到一个队列中let has = &#123;&#125;;let pending = falsefunction flushWatcher()&#123;    queue.forEach(item =&gt; &#123;item.run()&#125;)    queue = [];    has = &#123;&#125;    pending = false&#125;function queueWatcher(watcher)&#123;    let id = watcher.id //每个组件共用同一个watcher    if(!has[id])&#123;//去重        queue.push(watcher);        has[id] = true;        //防抖        if(!pending)&#123;            nextTick(flushWatcher) //相当于定时器,异步        &#125;        pending = true    &#125;&#125;\n\n将操作放入异步队列中，进行同步执行nextTick.js文件\n123456789101112131415161718192021222324252627282930313233343536let callBack = [] //列队：1、是vue自己的nextTick, 2、$nextTick回调函数let pending = falsefunction flush()&#123;    callBack.forEach(cb =&gt; &#123;        cb();    &#125;)    pending = false&#125;let timerFunc//处理兼容问题if(Promise)&#123;    timerFunc = () =&gt; &#123;        Promise.resolve().then(flush)//使所有函数同步操作    &#125;&#125;else if(MutationObserver)&#123;//h5异步方法，监听dom变化，监控完毕后进行异步更新    let observe = new MutationObserver(flush)    let texNode = document.createTextNode(1)    observe.observe(texNode,&#123;characterData: true&#125;);    timerFunc = () =&gt;&#123;        texNode.textContent = 2    &#125;&#125;else if(setImmediate)&#123;//ie    timerFunc = () =&gt; &#123;        setImmediate(flush)    &#125;&#125;export function nextTick(cb)&#123;    callBack.push(cb);    if(!pending)&#123;        timerFunc();        pending = true    &#125;&#125;\n\n定义 $nextTick APIinitState.js，初始化定义一个 $nextTick API，将回调函数放入 $nextTick 中\n12345export function stateMixin(vm)&#123;    vm.prototype.$nextTick = function(cb) &#123;        nextTick(cb)    &#125;&#125;\n\n$nextTick的使用场景\n  \n    \n        数据变化后立即获取 DOM 元素：例如，你可能需要在数据变化后立即获取 DOM 元素的尺寸或属性。\n    \n    \n        父子组件通信：在某些情况下，子组件需要在父组件更新后执行某些操作。\n    \n  \n","slug":"Vue-2-6源码分析之nextTick原理","date":"2024-07-10T08:03:25.000Z","categories_index":"Vue,总结,Vue源码","tags_index":"Vue,Vue源码","author_index":"May"},{"id":"b1597152b0a9a80173a513e01c3e8d7a","title":"Vue-2-6源码分析之初次渲染及生命周期","content":"\n  \n\n\n渲染流程：\n  \n    依次判断是否有render、template；\n  \n  \n    在没有template且存在el,就直接拿el.outerHTML；\n  \n   \n    有template且存在el：\n    \n      生成ast语法树\n      生成render函数\n    \n  \n   \n    生成虚拟节点\n  \n  \n    真实节点挂载到页面上\n  \n\n\n生命周期生命周期详解\n\n   beforeCreate：\n  \n    \n      在创建完这个Vue实例之后，会进入一个初始化阶段，初始化生命周期和事件，但数据代理还并没有开始，因此这个阶段是拿不到vm对象以及_data数据的。\n    \n  \n\n   created：\n  \n    \n      进行了数据监测和数据代理的，获取到代理对象。\n    \n  \n  \n\n   beforeMount：\n  \n    \n      Vue已经解析完成的真实DOM，但是此时的vue还没来的及将这些DOM向页面中存放。\n    \n  \n \n\n   mounted：\n  \n    \n      将内存中的虚拟DOM转化为真实DOM存在页面中,在这个函数中对DOM的操作均有效;\n    \n    \n      一般会进行这些操作：开启定时器，发送网络请求，订阅消息，绑定自定义事件等操作\n    \n  \n\n\n   beforeUpdate\n  \n    \n      只要data中的数据发生改变，那么就会触发这个钩子函数;\n    \n    \n      页面上渲染的数据和被改变的数据没有保持同步，就是页面还没有来得及展示被修改的值。\n    \n  \n  \n\n   updated\n  \n    \n      在这个阶段，就会生成新的虚拟DOM，随后通过diff算法，实现新旧的虚拟DOM的比较，最终完成页面的更新。\n    \n  \n\n\n   beforeDestory\n  \n    \n      销毁的实例中的所有的data，methods还有指令等等都是处于可用状态，但是不能对实例中的具体的数据和方法进行一个操作;\n    \n    \n      清除定时器、解绑自定义事件、取消消息订阅等。\n    \n  \n \n\n   destoryed\n  \n    \n      vue实例算是彻底的被销毁了，但是页面上的数据是还在的，但是不能操作上面的数据了。\n    \n  \n\n\n\n","slug":"Vue-2-6源码分析之初次渲染及生命周期","date":"2024-06-27T03:50:12.000Z","categories_index":"Vue,总结,Vue源码","tags_index":"Vue,Vue源码","author_index":"May"},{"id":"15483feced1e2a527f0fd1a7479d5986","title":"语音识别延伸之滚动定位","content":"前言数组每添加一条数据scroll-view需自动滚动到最底部;scroll-view高度动态改变\n\n\n    \n    \n\n\n具体代码scroll-view 的设置主要是设置 scroll-view 的scroll-top:scroll-with-animation&#x3D;”true”滚动时添加滑动效果，过渡更自然；\n123456789&lt;scroll-view scroll-y=&quot;true&quot;    ref=&quot;contentBox&quot;    :scroll-with-animation=&quot;true&quot;    :scroll-top=&quot;scrollTop&quot;    class=&quot;content&quot;    :style=&quot;&#123;height:scrollViewHeight+&#x27;px&#x27;&#125;&quot;&gt;    &lt;view id=&quot;content&quot; ref=&quot;contentBox&quot;&gt;    &lt;/view&gt;&lt;/scroll-view&gt;\n\n切换发送信息模式时动态设置 scroll-view 的高度1234567getScrollViewHeight(height)&#123;    this.$nextTick(()=&gt;&#123;        uni.createSelectorQuery().in(this).select(&#x27;.AIrecognition&#x27;).boundingClientRect((res)=&gt;&#123;          this.scrollViewHeight = res.height - height;        &#125;).exec();    &#125;)&#125;,\n\n123456789 watch: &#123;    sendMethods_keyBoard(val)&#123;        if(!val)&#123;            this.getScrollViewHeight(345);        &#125;else&#123;            this.getScrollViewHeight(175);        &#125;    &#125;&#125;,\n\n监听添加数据时滚动到最底部tip:如果用 this.$nextTick 会因为数据还没更新完成就加载页面，导致页面数据被隐藏一部分；所以要用 setTimeout\n12345678910scrollToBottom()&#123;    setTimeout(() =&gt; &#123;        uni.createSelectorQuery().in(this).select(&#x27;#content&#x27;).boundingClientRect((res)=&gt;&#123;            let top = res.height-this.scrollViewHeight;            if(top&gt;0)&#123;                this.scrollTop=top;            &#125;        &#125;).exec()    &#125;,300)&#125;,\n\n1234567watch: &#123;    content_list() &#123;      this.$nextTick(() =&gt; &#123;        this.scrollToBottom();      &#125;);    &#125;,&#125;,\n","slug":"语音识别延伸之滚动定位","date":"2024-05-24T06:21:42.000Z","categories_index":"经验","tags_index":"语音识别 -滚动定位","author_index":"May"},{"id":"4407c684d9dcb340bbb7fb0a49aa746d","title":"uniapp之语音识别","content":"前言在hbuilder中引入百度语音识别集成平台，实现&nbspAI语音识别\n\n\n    \n\n\n操作方式引入百度语音&nbspmanifest.json文件\n\n\n\n百度 AI 平台获取 key 值https://blog.csdn.net/zcs2632008/article/details/123306370\n唤起百度语音&nbsp@longpress长按屏幕&nbsp@touchend松开触碰\n\n123456789 &lt;view class=&quot;img&quot;    :class=&quot;longPressing ? &#x27;longPressing&#x27; : &#x27;&#x27;&quot;    @longpress=&quot;startRecognize&quot; @touchend=&quot;endRecognize&quot; @touchmove=&quot;endRecognize&quot;&gt;    &lt;image        src=&quot;https://yizhu-new.oss-cn-shenzhen.aliyuncs.com/app_img/cImg/AIrecognition9.png&quot;    /&gt;    &lt;/view&gt;    &lt;view class=&quot;text&quot; v-if=&quot;!longPressing&quot;&gt;长按说话&lt;/view&gt;&lt;/view&gt;\n\n&nbsponLoad钩子中进行监听\n\n123456// 监听语音识别事件plus.speech.addEventListener(&#x27;start&#x27;, this.ontStart, false);plus.speech.addEventListener(&#x27;volumeChange&#x27;, this.onVolumeChange, false);plus.speech.addEventListener(&#x27;recognizing&#x27;, this.onRecognizing, false);plus.speech.addEventListener(&#x27;recognition&#x27;, this.onRecognition, false);plus.speech.addEventListener(&#x27;end&#x27;, this.onEnd, false);\n\n&nbsp@longpress=\"startRecognize\"开始识别\n123456789101112startRecognize() &#123;    console.log(&#x27;startRecognize&#x27;);    let options = &#123;    engine: &#x27;baidu&#x27;,    lang: &#x27;zh-cn&#x27;,    userInterface: true,    continue: false,    timeout:  60 * 1000,    punctuation: false    &#125;    plus.speech.startRecognize(options)&#125;,\n\n触发监听相关函数\n1234567891011121314151617181920212223242526ontStart() &#123;    this.title = &#x27;...倾听中...&#x27;;    this.text = &#x27;&#x27;;    console.log(&#x27;Event: start&#x27;);&#125;,onVolumeChange(e) &#123;    this.valueWidth = 100*e.volume+&#x27;px&#x27;;&#125;,onRecognizing(e) &#123;    console.log(&#x27;Event: recognizing&#x27;);&#125;,onRecognition(e) &#123;    console.log(e.result,&#x27;e.resulte.resulte.result&#x27;);    this.text += e.result;    this.text?(this.text+=&#x27;\\n&#x27;):this.text=&#x27;&#x27;;    this.text_content = this.text;//将识别的到信息进行赋值    console.log(&#x27;Event: recognition&#x27;);    plus.speech.stopRecognize();&#125;,onEnd() &#123;    if(!this.text||this.text==&#x27;&#x27;)&#123;        plus.nativeUI.toast(&#x27;没有识别到内容&#x27;);    &#125;    this.text_content = this.text;    plus.speech.stopRecognize();&#125;,\n\n&nbsp @touchend=\"endRecognize\"结束识别\n1234endRecognize() &#123;    console.log(&#x27;endRecognize&#x27;);    plus.speech.stopRecognize();&#125;,\n","slug":"uniapp之语音识别","date":"2024-05-23T03:42:24.000Z","categories_index":"经验","tags_index":"uniapp,语音识别","author_index":"May"},{"id":"8cb2683bb6a5c8d0f688364471819883","title":"小程序分包","content":"前言微信小程序分包常用于代码量较大的小程序，发布时会受到大小限制\n\n什么是分包分包指的是把一个完整的小程序项目，按照需求划分为不同的子包，在构建时打包成不同的分包，用户在使用时按需进行加载\n分包的好处可以优化小程序首次启动的下载时间在多团队共同开发时可以更好的解耦协作\n操作方式1、建立分包文件夹在项目根目录下创建分包文件夹 pageA、pageB： 只包含和当前分包有关的页面和私有资源；pages 主包：一般只包含项目的启动页面或 TabBar 页面、以及所有分包都需要用到的一些公共资源。\n\n2、文件配置\n打包原则① 小程序会按 subpackages 的配置进行分包，subpackages 之外的目录将被打包到主包中② 主包也可以有自己的 pages（(即最外层的 pages 字段)③tabBar 页面必须在主包内④ 分包之间不能互相嵌套\n引用原则① 主包无法引用分包内的私有资源② 分包之间不能相互引用私有资源③ 分包可以引用主包内的公共资源\n分包–独立分包1.什么是独立分包独立分包本质上也是分包，只不过它比较特殊，可以独立于主包和其他分包而单独运行。\n2、独立分包和普通分包的区别·普通分包必须依赖于主包才能运行·独立分包可以在不下载主包的情况下，独立运行\n3、独立分包的应用场景开发者可以按需，将某些具有一定功能独立性的页面配置到独立分包中。原因如下:当小程序从普通的分包页面启动时，需要首先下载主包而独立分包不依赖主包即可运行，可以很大程度上提升分包页面的启动速度注意:一个小程序中可以有多个独立分包。\n4、独立分包的配置方法1&quot;independent&quot;: true\n\n5、引用原则① 主包无法引用独立分包内的私有资源② 独立分包之间，不能相互引用私有资源③ 独立分包和普通分包之间，不能相互引用私有资源**④ 特别注意:**独立分包中不能引用主包内的公共资源\n分包–分包预下载1.什么是分包预下载分包预下载指的是:在进入小程序的某个页面时，由框架自动预下载可能需要的分包，从而提升进入后续分包页面时的启动速度。\n2.配置分包的预下载预下载分包的行为，会在进入指定的页面时触发。在 app.json 中，使用 preloadRule 节点定义分包的预下载规则，示例代码如下:\n123456789101112 &quot;preloadRule&quot;: &#123;//分包预下载规则   &quot;pages/contact/contact&quot;:&#123;//触发分包预下载的页面路径   \t//packages表示进入页面后，预下载哪些分包   \t//可以通过root或name指定预下载哪些分包     &quot;packages&quot;: [&quot;p1&quot;],     //network表示在指定的网络模式下进行预下载， //可选值为: all（不限网络）和 wifi（仅wifi模式下进行预下载）//默认值为: wifi     &quot;network&quot;: &quot;wifi&quot;   &#125; &#125;,\n","slug":"小程序分包","date":"2024-05-10T07:08:26.000Z","categories_index":"总结","tags_index":"小程序","author_index":"May"},{"id":"2ea9c9ee829119d28adc607282fb8e16","title":"uniapp下小程序获取详细定位","content":"前言uniapp自带的API uni.getLocation仅APP端支持获取adress，小程序是不支持的。\n\n因此可以借助腾讯/高德的API 地理/逆地理编码\n\n授权地理位置manifest.json 该文件中添加以下代码，会弹出位置授权弹框。\n1234567&quot;mp-weixin&quot; : &#123;    &quot;permission&quot; : &#123;        &quot;scope.userLocation&quot; : &#123;            &quot;desc&quot; : &quot;将获取你的地址&quot;        &#125;    &#125;,&#125;\n\n但有些用户可能会选择关闭，因为当进入到需要获取地理位置的的页面时就无法进行定位，因为最好在具体页面再进行一次位置的授权\n\n\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243 getIsAuthority()&#123;    var that = this;    uni.getSetting(&#123;        success: (res) =&gt; &#123;            if (res.authSetting[&#x27;scope.userLocation&#x27;] != undefined &amp;&amp; res.authSetting[&#x27;scope.userLocation&#x27;] != true) &#123;//非初始化进入该页面,且未授权            uni.showModal(&#123;                title: &#x27;是否授权当前位置&#x27;,                content: &#x27;需要获取您的地理位置，请确认授权，否则地图功能将无法使用&#x27;,                success: function (res) &#123;                if (res.cancel) &#123;                    console.info(&quot;授权失败返回数据&quot;);                &#125; else if (res.confirm) &#123;                    uni.openSetting(&#123;                        success: function (data) &#123;                            if (data.authSetting[&quot;scope.userLocation&quot;] == true) &#123;                            uni.showToast(&#123;                                title: &#x27;授权成功&#x27;,                                icon: &#x27;success&#x27;,                                duration: 5000                            &#125;)                            //再次授权，调用getLocationt的API                            that.getCurrentLocation(that);                            &#125;else&#123;                            uni.showToast(&#123;                                title: &#x27;授权失败&#x27;,                                icon: &#x27;success&#x27;,                                duration: 5000                            &#125;)                            &#125;                        &#125;                        &#125;)                    &#125;                    &#125;                &#125;)            &#125; else if (res.authSetting[&#x27;scope.userLocation&#x27;] == undefined) &#123;//初始化进入                that.getCurrentLocation(that);            &#125;else&#123;                that.getCurrentLocation(that);            &#125;        &#125;    &#125;)&#125;,\n\n腾讯位置服务进行设置腾讯位置服务\n详细步骤点击链接查看:步骤设置\n12345678910111213141516171819202122232425262728293031323334353637383940//获取定位   getCurrentLocation(thatParam) &#123;       let that = thatParam       uni.getLocation(&#123;           type: &#x27;gcj02&#x27;,// (！！！必需)默认为 wgs84 返回 gps 坐标，gcj02（更准确） 返回可用于 uni.openLocation 的坐标           isHighAccuracy: true,//开启高精度定位(！！！必需)           success: function(res) &#123;               that.form.longitude = &quot;经度： &quot; +  res.longitude.toFixed(5) + &quot;  &quot; + &quot;纬度： &quot; + res.latitude.toFixed(5);               //根据获取的经纬度去解析当前坐标的地址信息               that.loAcquire(res.longitude, res.latitude)           &#125;,           fail: function(error) &#123;               uni.showToast(&#123;                   title: &#x27;无法获取位置信息！无法使用位置功能&#x27;,                   icon: &#x27;none&#x27;,               &#125;)           &#125;       &#125;);   &#125;,   //根据获取的经纬度去解析当前坐标的地址信息   loAcquire(longitude, latitude) &#123;       let that = this;       uni.showLoading(&#123;           title: &#x27;加载中&#x27;,           mask: true       &#125;);       uni.request(&#123;           url: &#x27;https://apis.map.qq.com/ws/geocoder/v1/?location=&#x27;,           method: &#x27;GET&#x27;,           data: &#123;               key: key,               location: `$&#123;res.longitude&#125;,$&#123;res.latitude&#125;`           &#125;,           success: (e) =&gt; &#123;           &#125;,           fail: () =&gt; &#123;           &#125;       &#125;)   &#125;\n","slug":"uniapp下小程序获取详细定位","date":"2024-04-15T07:53:36.000Z","categories_index":"经验","tags_index":"uniapp小程序,地图","author_index":"May"},{"id":"fc0084e39f16c44f947668a585ecf5c2","title":"旧版本Vuex如何做持久化","content":"怎么实现vuex的持久化缓存Vuex持久化缓存通常指的是将Vuex中的state状态保存到本地存储中，这样即使在页面刷新或关闭后，重新打开页面仍然可以恢复之前的状态。实现Vuex持久化缓存有几种不同的方法，以下是一些常见的实现方式：\n使用localStorage或sessionStorage我们可以手动将Vuex的state序列化后保存到localStorage或sessionStorage中，并在应用启动时从存储中恢复状态。\n12345678910111213141516171819202122232425262728293031// 保存state到localStoragefunction saveToStorage(state) &#123;  localStorage.setItem(&#x27;vuex-state&#x27;, JSON.stringify(state));&#125;​// 从localStorage恢复statefunction loadFromStorage() &#123;  const storedState = localStorage.getItem(&#x27;vuex-state&#x27;);  return storedState ? JSON.parse(storedState) : &#123;&#125;;&#125;​// 在Vuex的mutations中使用const mutations = &#123;  saveState(state) &#123;    saveToStorage(state);  &#125;&#125;;​// 在Vuex的actions中恢复stateconst actions = &#123;  restoreState(&#123; commit &#125;) &#123;    const savedState = loadFromStorage();    if (Object.keys(savedState).length) &#123;      commit(&#x27;hydrateState&#x27;, savedState);    &#125;  &#125;&#125;;​// 在组件中或在应用启动时调用恢复state的actiondispatch(&#x27;restoreState&#x27;);\n\n快速使用：vuex-persist插件npm install vuex-persist，然后，在我们的Vuex store中使用这个插件：\n12345678910111213141516171819javascript复制代码import Vue from &#x27;vue&#x27;;import Vuex from &#x27;vuex&#x27;;import vuexPersist from &#x27;vuex-persist&#x27;;​Vue.use(Vuex);​const store = new Vuex.Store(&#123;  // ...我们的state, mutations, actions等&#125;);​const vuexPersist = new vuexPersist(&#123;  key: &#x27;vuex&#x27;, // 存储的名称  storage: window.localStorage, // 存储方式，可以选择sessionStorage或localStorage  // 其他配置...&#125;);​// 使用插件vuexPersist.plugin(store);\n\n注意\n\n序列化: 当我们将state保存到本地存储时，确保state中的数据可以被序列化。这意味着state中不应该包含函数、undefined等不能被JSON序列化的数据。\n安全性: 存储在localStorage或sessionStorage中的数据可以被同源的任何JavaScript代码访问，因此不要存储敏感信息。性能: 避免频繁地读写本地存储，因为这可能会影响性能。\n\nvuex-persist 插件扩展vuex-persist是一个第三方Vuex插件，它提供了一种简便的方式来持久化Vuex的状态。这个插件的实现基于几个关键步骤：\n\n序列化状态: 插件首先会将Vuex store的状态（state）序列化成JSON字符串。这是通过JSON.stringify()实现的，确保状态对象中所有的数据都是可以被序列化的。\n存储状态: 序列化后的状态字符串被保存到浏览器的localStorage或sessionStorage中。vuex-persist允许我们通过配置来选择使用哪一种存储方式。监听状态变化: 插件会监听Vuex store的状态变化。每当状态发生变化时，插件都会自动将新的状态序列化并更新到本地存储中。这通常是通过订阅Vuex store的mutation事件来实现的。\n恢复状态: 当应用启动或者需要从持久化存储中恢复状态时，插件会从localStorage或sessionStorage中读取状态字符串，并使用JSON.parse()将其解析回原始的对象结构。\n自动恢复: vuex-persist通常在Vuex store初始化时自动执行状态恢复的逻辑。这意味着在我们的应用启动时，如果本地存储中有保存的状态，vuex-persist会自动恢复这些状态。\n配置选项: vuex-persist提供了多种配置选项，允许我们定制化持久化的行为。例如，我们可以配置要持久化的state片段（通过paths选项），或者设置一个函数来在保存之前过滤状态（通过reducer选项）。\n版本控制: 插件还可以处理版本控制问题，如果我们的应用升级后state结构发生了变化，vuex-persist可以通过配置（如reducer函数）来确保向后兼容。\n集成Vuex严格模式: 当Vuex store配置为严格模式时，vuex-persist能够确保所有状态的变更都是通过mutations进行的，即使这些变更是由插件自身触发的。\n\n","slug":"Vuex本地持久化","date":"2024-02-10T16:00:00.000Z","categories_index":"","tags_index":"Vue,Vuex","author_index":"May"},{"id":"d02145c722134b6141381c5add87923b","title":"服务器之正向代理和反向代理","content":"最近公司商家入驻准备上线，和运维在服务器代理这边折腾了不少时间，现在重新归纳一下正向代理和反向代理的相关概念和区别\n正向代理简述：正向代理服务器作接受来自客户端的请求，请求源服务器，把原服务器返回的内容响应给客户端\n注意：(此时源服务器并不知道客户端是谁)\n\n正向代理的应用&#x2F;使用原因：\n\n网址被墙，就可以在外网架设一个服务器作为中间服务器进行代理转发\n隐藏自身的浏览行为\n\n反向代理简述: 同正向代理一样，但是客户端并不知道实际访问的源服务器是谁，因为源服务器实际上可能会有多个，所以实际上像访问谷歌这种网页，都是要经过一层反向代理的服务器\n\n反向代理的应用&#x2F;使用原因：\n\n基于安全原因，不想直接暴露源服务器地址，就可以使用一个反向代理服务器，连接内外网，将反向代理服务器层作为类防火墙功能，进行安全校验。\n服务器负载均衡，访问一个资源时，根据源服务器的具体工作情况，分发到合适的服务器之中)\n\n反向代理和正向代理的区别\n\n\n\n\n\n\n\n\n正向代理服务器只对客户端负责，即隐藏用户\n\n\n\n\n\n\n\n\n\n反向代理服务器只对自己所代理的服务器负责，即隐藏源服务器\nVue 框架的开发时反向代理服务器路径设置及其区别12345678910// 请求地址 /api/blog/tags&#x27;/api&#x27; : &#123;target: &#x27;http://127.0.0.1:7001&#x27;,  pathRewrite: &#123;    &#x27;^/api&#x27;: &#x27;/blog&#x27; // 重写了url 相当于请求 http://127.0.0.1:7001/blog/blog/tags    &#x27;^/api&#x27;: &#x27;&#x27; // 重写了url 相当于请求 http://127.0.0.1:7001/blog/tags    &#x27;&#x27;: &#x27;&#x27; // 重写了url 相当于请求 http://127.0.0.1:7001/api/blog/tags  &#125;&#125;\n","slug":"服务器之正向代理和反向代理","date":"2021-07-27T16:00:00.000Z","categories_index":"总结","tags_index":"http","author_index":"May"},{"id":"977046a105528b08c6104c9e8e95e023","title":"HTTP缓存机制记录","content":"http 缓存机制很容易就忘记了 这里大概记录一下\n简单概括http 缓存分为强缓存(Cache-Control &gt; Expires),协商缓存(Etag &#x2F; If-None-Match &gt; Last-Modified &#x2F; If-Modified-Since)强缓存和协商缓存的区别&gt; 强缓存命中的情况下不和服务器做交互，协商缓存不管有没有命中都会和服务器做交互\n第一次请求\n浏览器发起 http 请求到服务器。\nhttp 请求通过浏览器缓存，浏览器缓存没有发现该请求的缓存标识和缓存结果，会直接放行，让 http 请求直接请求到服务器。\n服务器返回请求结果和缓存规则给浏览器\n浏览器将请求结果和缓存标识存入浏览器缓存中，作为下一次请求的标识\n\n第二次请求命中强缓存的情况\nExpires 该字段作为缓存标志， 如果客户端的时间小于 Expires 的值时，就直接使用缓存结果，但是这只是存在于 HTTP&#x2F;1.0 中，现今大部分已经被 Cache-Control 所替代\nCache-Control HTTP1.1 所使用的标识，该字段有以下几种属性\npublic：所有内容都将被缓存（客户端和代理服务器都可缓存）\nprivate：所有内容只有客户端可以缓存，Cache-Control 的默认取值\nno-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定\nno-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存\nmax-age&#x3D;xxx (xxx is numeric)：缓存内容将在 xxx 秒后失效\n\n第二次请求\n强缓存未命中，协商缓存命中的情况当协商缓存命中时，服务器返回 304 状态码表示该资源没有更新协商缓存字段有 Last-Modified &#x2F; If-Modified-Since 和 Etag &#x2F; If-None-Match，其中 Etag &#x2F; If-None-Match 的优先级比 Last-Modified &#x2F; If-Modified-Since 高。\nIf-None-Match&#x2F;Etag &#x3D;&gt; 客户端再次发起该请求时，携带上次请求返回的唯一标识 Etag 值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有 If-None-Match，则会根据 If-None-Match 的字段值与该资源在服务器的 Etag 值做对比，一致则返回 304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，返回 200\nLast-Modified&#x2F;If-Modified-Since &#x3D;&gt; 则是客户端再次发起该请求时，携带上次请求返回的 Last-Modified 值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有 If-Modified-Since 字段，则会根据 If-Modified-Since 的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于 If-Modified-Since 的字段值，则重新返回资源，状态码为 200；否则则返回 304，代表资源无更新，可继续使用缓存文件\n\n","slug":"HTTP缓存机制记录","date":"2019-12-03T16:00:00.000Z","categories_index":"http,总结","tags_index":"http","author_index":"May"},{"id":"c56ee70c55fbd1ff18b7573952b52a52","title":"CSS多行溢出处理","content":"前言之前做过的布局文字溢出效果 一段时间不用之后就老是忘记 今天记录下来\n单行溢出123overflow: hidden;text-overflow: ellipsis;white-space: nowrap;\n\n多行溢出(webkit)1234overflow: hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 2; // 在第几行处省略-webkit-box-orient: vertical;\n","slug":"CSS多行溢出处理","date":"2019-10-02T16:00:00.000Z","categories_index":"CSS样式","tags_index":"CSS,SCSS","author_index":"May"}]