[{"id":"fc0084e39f16c44f947668a585ecf5c2","title":"旧版本Vuex如何做持久化","content":"怎么实现vuex的持久化缓存Vuex持久化缓存通常指的是将Vuex中的state状态保存到本地存储中，这样即使在页面刷新或关闭后，重新打开页面仍然可以恢复之前的状态。实现Vuex持久化缓存有几种不同的方法，以下是一些常见的实现方式：\n使用localStorage或sessionStorage我们可以手动将Vuex的state序列化后保存到localStorage或sessionStorage中，并在应用启动时从存储中恢复状态。\n12345678910111213141516171819202122232425262728293031// 保存state到localStoragefunction saveToStorage(state) &#123;  localStorage.setItem(&#x27;vuex-state&#x27;, JSON.stringify(state));&#125;​// 从localStorage恢复statefunction loadFromStorage() &#123;  const storedState = localStorage.getItem(&#x27;vuex-state&#x27;);  return storedState ? JSON.parse(storedState) : &#123;&#125;;&#125;​// 在Vuex的mutations中使用const mutations = &#123;  saveState(state) &#123;    saveToStorage(state);  &#125;&#125;;​// 在Vuex的actions中恢复stateconst actions = &#123;  restoreState(&#123; commit &#125;) &#123;    const savedState = loadFromStorage();    if (Object.keys(savedState).length) &#123;      commit(&#x27;hydrateState&#x27;, savedState);    &#125;  &#125;&#125;;​// 在组件中或在应用启动时调用恢复state的actiondispatch(&#x27;restoreState&#x27;);\n\n快速使用：vuex-persist插件npm install vuex-persist，然后，在我们的Vuex store中使用这个插件：\n12345678910111213141516171819javascript复制代码import Vue from &#x27;vue&#x27;;import Vuex from &#x27;vuex&#x27;;import vuexPersist from &#x27;vuex-persist&#x27;;​Vue.use(Vuex);​const store = new Vuex.Store(&#123;  // ...我们的state, mutations, actions等&#125;);​const vuexPersist = new vuexPersist(&#123;  key: &#x27;vuex&#x27;, // 存储的名称  storage: window.localStorage, // 存储方式，可以选择sessionStorage或localStorage  // 其他配置...&#125;);​// 使用插件vuexPersist.plugin(store);\n\n注意\n\n序列化: 当我们将state保存到本地存储时，确保state中的数据可以被序列化。这意味着state中不应该包含函数、undefined等不能被JSON序列化的数据。\n安全性: 存储在localStorage或sessionStorage中的数据可以被同源的任何JavaScript代码访问，因此不要存储敏感信息。性能: 避免频繁地读写本地存储，因为这可能会影响性能。\n\nvuex-persist 插件扩展vuex-persist是一个第三方Vuex插件，它提供了一种简便的方式来持久化Vuex的状态。这个插件的实现基于几个关键步骤：\n\n序列化状态: 插件首先会将Vuex store的状态（state）序列化成JSON字符串。这是通过JSON.stringify()实现的，确保状态对象中所有的数据都是可以被序列化的。\n存储状态: 序列化后的状态字符串被保存到浏览器的localStorage或sessionStorage中。vuex-persist允许我们通过配置来选择使用哪一种存储方式。监听状态变化: 插件会监听Vuex store的状态变化。每当状态发生变化时，插件都会自动将新的状态序列化并更新到本地存储中。这通常是通过订阅Vuex store的mutation事件来实现的。\n恢复状态: 当应用启动或者需要从持久化存储中恢复状态时，插件会从localStorage或sessionStorage中读取状态字符串，并使用JSON.parse()将其解析回原始的对象结构。\n自动恢复: vuex-persist通常在Vuex store初始化时自动执行状态恢复的逻辑。这意味着在我们的应用启动时，如果本地存储中有保存的状态，vuex-persist会自动恢复这些状态。\n配置选项: vuex-persist提供了多种配置选项，允许我们定制化持久化的行为。例如，我们可以配置要持久化的state片段（通过paths选项），或者设置一个函数来在保存之前过滤状态（通过reducer选项）。\n版本控制: 插件还可以处理版本控制问题，如果我们的应用升级后state结构发生了变化，vuex-persist可以通过配置（如reducer函数）来确保向后兼容。\n集成Vuex严格模式: 当Vuex store配置为严格模式时，vuex-persist能够确保所有状态的变更都是通过mutations进行的，即使这些变更是由插件自身触发的。\n\n","slug":"Vuex本地持久化","date":"2024-02-10T16:00:00.000Z","categories_index":"","tags_index":"Vue,Vuex","author_index":"谢小谢"},{"id":"be8b20988d64ed90b36f55c5730a76e9","title":"记一次uni-app原生应用高德地图配置的坑","content":"前言为配合打荷生鲜 2.0 小程序的发展，需要对配送人员增加一个类似于美团骑手版的安卓 App，为此需要引入高德地图的 sdk，折腾了我一天的时候，为此将遇到的问题记录下来\n新开项目如何引用 uni-app 原生插件？\n创建新项目，记录下 appId\n将新项目与第三方插件绑定\n项目配置再次进行绑定\n\n至此，插件的初步使用已经完成\n如何结合高德地图 sdk？\n登录 DCloud 开发者中心，我的应用，应用信息-&gt;各平台信息，记下包名&#x2F;appid，应用信息-&gt;Android 云端证书-&gt;证书详情，记下证书的别名， SHA1 码，密码，并把证书下载到本地\n前往高德地图控制台-&gt;应用管理-&gt;我的应用-&gt;创建应用，配置应用的 packageName 和 SHA1 码一定要和 Dcloud 的证书一致，不一致的话，基座打包后调用 api 会报 ERROR_CODE:7 错误\n创建应用配置完，回到列表拿到应用的 key，回填到 uni-app 项目配置中\n基座打包，填写包名，证书别名，密码，上传证书，开始进行打包\n真机调试，打开 Hbuilder&#x2F;Hbuilderx-&gt;运行-&gt;运行到手机或模拟器-&gt;运行到 Android App 基座-&gt; 使用自定义基座运行\n\n总结主要的坑点还是在 packageName 包名那块，官方也没说明怎么生成 SHA1 码，于是就自己用 keytool 自己生成了，结果显而易见，一直卡在那边，通过慢慢结合网上摸索才得出解决办法。\n","slug":"记一次uni-app原生应用高德地图配置的坑","date":"2023-11-15T16:00:00.000Z","categories_index":"经验","tags_index":"原生小程序,高德地图","author_index":"谢小谢"},{"id":"717767a9d0fa35b0ddd204ab9b9e0cde","title":"厨易科技低代码平台搭建思考","content":"由于公司之前的项目用的有赞的 saas，每年的费用高达几十万，对于小公司来说是一笔不小的支出所以另行组建了团队。我 5 月份进来作为前端这块的组长，在主导小程序的时候，另外一个比较重要的任务是需要从 0 到 1 主导管理低代码物料平台，以支持运营同事小程序前端的自定义编辑操作，后期可能还要兼容到 H5\n技术选型目前市面上不管是 Vue 或者 React 已经有了较为成熟的方案，搭配公司主要技术栈，还是以 Vue3 全家桶搭配 vite&#x2F;webpack 这一套为主\n低代码平台的操作方式\n\n\n市面方案\n优缺点\n难易度\n\n\n\n代码驱动+json 段\n比较适合开发人员作为主要操作者\n有一定难度，特别对于不会代码的同学\n\n\n拖拽驱动+自定义配置\n适合对技术一窍不通的小白\n基本无难度\n\n\n基于公司运营同学本身特点优先还是选用了拖拽驱动+自定义配置\n基础 demo 图 如下\n可以预见的难点\nPC 端尺寸单位为 px，小程序前台为 rpx，是否需要做兼容？\nPC 端组件的组件为原生，小程序是自己封装的一套，如何进行适配？\n如果有商品组件的话，或者更多需要网络请求的，如何动态化保存当前组件中商品信息，在前端如何自定义请求？\n组件中可能会存在很多用户态的校验，事件绑定逻辑的情况，这一块要如何处理？\n预览和草稿功能的实现\n\n问题 1通常不需要做兼容，因为公司 UI 的宽度都是以 375 的屏幕宽度来定义设计图，在前台设编辑器窗口计预览的时候，把宽度也定义成 375 既可\n问题 2由于公司小程序是原生的，并不具备像 uni-app 或 taro 这种条件编译的情况，所以两边没办法用同一套的方案，除非后面基本技术栈转成 taro 或 uni-app。那目前的办法就只能在 PC 维护一套，然后自行通过小程序语法做人工的同步功能适配。\n问题 3商品组件中如果有网络请求的情况下，目前想到的解决方法有 2 个：第一是前端通过数据模型对象数组项里面的某一个 key 值，判断某一个 key 来做 http 请求处理，这样的性能好，但是体验差。第二是把当前选择商品放在后端，后端查询后集体返回，这样的话体验好，但是网络请求的时间可能会稍长，经过深思熟虑后还是选用了前者\n问题 4事件绑定的情况下，数据模型单独拎出一个 key，循环所有的 key 挂载在小程序 this 对象里面，小程序端和 PC 端同步命名，这样可以解决事件绑定问题。对于用户态，只需要在小程序事件绑定方法内增加一个用户态拦截指令即可\n问题 5预览和保存功能由于是在 H5 端，所以处理方式都是通过数据模型来做映射，好的一点是可以和 PC 那边一样共用组件，减少开发二次开发的难度\n总结此 下一篇。\n","slug":"厨易科技低代码平台搭建思考","date":"2023-06-30T16:00:00.000Z","categories_index":"低代码","tags_index":"原生小程序,物料系统","author_index":"谢小谢"},{"id":"e9f45a92e7df43e08b58c2d1279189cb","title":"Vue3自定义图片懒加载指令","content":"之前用习惯了别人的图片懒加载指令，现在自己也试着写了一个，在这里记录下自己过程中的心得体会，当前指令逻辑使用于 vue2 和 vue3\n图片懒加载原理使用 html 自定义数据先覆盖图片或者背景图的默认地址，从少图片资源加载，当滚动条拉动到可视区的时候才逐渐加载图片，从而提高网站性能 ## 目标 实现图片懒加载和背景图片的懒加载，并且支持自定义默认图片\n开始 需要明白的两点\n需要设置一个自定义默认图片的自定义属性\n需要传入一个值设置当前是图片的懒加载还是背景图片的懒加载，背景图片需要从一开始就设定好宽度，才能计算 下面开始代码\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import &#123; App, DirectiveBinding &#125; from &quot;vue&quot;;/** ** @Description: 设置样式 ** @Author: shuhongxie ** @param &#123;any&#125; arg 传入的类型 ** @param &#123;HTMLElement&#125; el DOM元素 ** @param &#123;string&#125; value 图片url值 **/function setStyle(arg: any, el: HTMLElement, value: string) &#123;  !arg    ? el.setAttribute(&quot;src&quot;, value)    : (el.style.backgroundImage = `url(\\&quot;$&#123;value&#125;\\&quot;)`);&#125;/** * * @Description: 初始化图片懒加载 * * @Author: shuhongxie * * @param &#123;HTMLElement&#125; el DOM元素 * * @param &#123;DirectiveBinding&#125; binding **/function initLazy(el: HTMLElement, binding: DirectiveBinding) &#123;  // 默认图片  const beforeHandImage =    el.getAttribute(&quot;lazy-init-img&quot;) || &quot;http://www.ay1.cc/img?w=300&amp;h=300&quot;;  // 屏幕高度   const contentHeight = document.body.clientHeight  // 不使用offsetTop是因为如果父级有定位的话 那么offsetTop是相对于父级而不是浏览器窗口  let elOffsetTop =    el.getBoundingClientRect().top + document.documentElement.scrollTop;  // 图片高度大于当前屏幕就替换调原始图片  if (elOffsetTop &gt; contentHeight) &#123;    // 没有就直接赋值当前图片    setStyle(binding.arg, el, beforeHandImage);  &#125; else &#123;    setStyle(binding.arg, el, binding.value);  &#125;  window.addEventListener(&quot;scroll&quot;, () =&gt; &#123;    const scrollTop =      document.documentElement.scrollTop ||      window.pageYOffset ||      document.body.scrollTop; // 刷新完重新定义高度    elOffsetTop =      el.getBoundingClientRect().top + document.documentElement.scrollTop; // 到达可视区就设置样式    if (scrollTop + contentHeight &gt; elOffsetTop) &#123;      setStyle(binding.arg, el, binding.value);    &#125;  &#125;);&#125;export default (app: App) =&gt; &#123;  // v-lazy 图片懒加载指令 beforeHandImage 初始化的图片  app.directive(&quot;lazy&quot;, &#123;    mounted(el, binding, vnode, oldVnode) &#123;      setTimeout(() =&gt; &#123;        initLazy(el, binding);      &#125;, 0);    &#125;,    updated(el, binding) &#123;      setTimeout(() =&gt; &#123;        initLazy(el, binding);      &#125;, 0);    &#125;,    unmounted() &#123;      window.removeEventListener(&quot;scroll&quot;, null);    &#125;,  &#125;);&#125;;\n\n可以看到，上图通过定义个一个 lazy-init-img 的自定义属性和传入了一个 background 指令参数来切换成背景图模式，不传则是图片模式，通过使用 getBoundingClientRect 方法获取到浏览器的距离，在所有队列任务执行完之后重新计算高度，执行对应的逻辑\n","slug":"Vue3自定义图片懒加载指令","date":"2023-02-24T16:00:00.000Z","categories_index":"vue3,经验","tags_index":"Vue3","author_index":"谢小谢"},{"id":"0f52401eaa7baffae19fe63567938437","title":"uni-app微信小程序实现axios请求拦截器和重复请求中断","content":"最近在写二手表微信小程序的时候，发现老是会有重复请求的情况，用了函数防抖和布尔拦截之后，又显得非常臃肿，没能从根本上解决问题，刚好 leader 叫我做一下重复请求拦截。可是，当我翻开 flyio 文档之后……\nWhat the fuck没想到 flyio 竟然没有预设重复请求功能，绝望\n\n当前目标和处理思路那么我的目标就变成了兼容旧 flyio 的拦截器功能，并且还要实现重复请求拦截功能。对接重复请求拦截，因为我们当前小程序只有微信端，那我就直接换成了微信小程序官方的请求，刚好也有请求中断功能。对于拦截器，基本都是通过 promise 来实现的，那这里就直接自己写一个。\n请求和响应拦截的思路通过 Promise.then 实现链式的串行调用，因为前置有请求拦截器，后置有响应拦截器，中间插入请求结构体。整体结构如下图\n\n代码细究整体工具库使用 lodash\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142export const callFor = (arrayData, fn) =&gt; &#123;  arrayData.forEach(item =&gt; &#123;    fn.call(null, item)  &#125;)&#125;// 全局拦截器实例export default class Interceptor &#123;  constructor() &#123;    this.handlers = []  &#125;  // use方法传入Promise两个状态处理语句  use(fulfilled, rejected) &#123;    this.handlers.push(&#123;      fulfilled,      rejected    &#125;)    return this.handlers.length - 1  &#125;&#125;// 主体请求参数 作为promise调用链的入参之一const requestFn = config =&gt; &#123;  const options = config  // requestTaskKey 当前重复请求的url标识  let lastRequestKey = config.hasOwnProperty(&#x27;requestTaskKey&#x27;) ? config.requestTaskKey : &#x27;&#x27;  // 如果全局变量数组里面含有当前的请求，那么就直接中断上一次请求  if (    lastRequestKey &amp;&amp;    getApp().hasOwnProperty(&#x27;requestTasks&#x27;) &amp;&amp;    getApp().requestTasks.hasOwnProperty(lastRequestKey)  ) &#123;    try &#123;      console.log(&#x27;中断了上一次的请求----------------------&#x27;)      getApp().requestTasks[lastRequestKey].abort()      // 中断后就应该清除掉      delete getApp().requestTasks[lastRequestKey]    &#125; catch (e) &#123;      console.error(e)    &#125;  &#125;  // 返回一个promise  return new Promise((resolve, reject) =&gt; &#123;    const url = options.baseURL + options.url    options.url = url    const requestTask = uni.request(&#123;      ...options,      complete: res =&gt; &#123;        console.log(res)        // 每一次成功之后 就清空当前url在全局变量数组里面的位置        // request:faile abort为公司自定义的错误请求状态，        if (res.errMsg !== &#x27;request:faile abort&#x27; &amp;&amp; lastRequestKey) &#123;          delete getApp().requestTasks[lastRequestKey]        &#125;        if (res.errMsg === &#x27;request:ok&#x27;) &#123;          return resolve(&#123; ...res, request: options &#125;)        &#125; else if (res.errMsg === &#x27;request:fail&#x27;) &#123;          return reject(&#123; ...res, request: options &#125;)        &#125;      &#125;    &#125;)    // 如果当前请求需要支持重复请求的中断，    if (lastRequestKey) &#123;      // 没有队列的情况下 全局变量存储队列      if (!getApp().requestTasks) &#123;        getApp().requestTasks = &#123;&#125;      &#125;      // 把当前请求塞入存储队列之中      getApp().requestTasks[lastRequestKey] = requestTask    &#125;  &#125;)&#125;function HttpRequest(config) &#123;  // 深拷贝配置防止配置被上一个请求修改  this.config = _.cloneDeep(    Object.assign(      &#123;&#125;,      &#123;        baseURL: &#x27;&#x27;,        url: &#x27;&#x27;,        data: &#123;&#125;,        header: &#123;&#125;,        method: &#x27;GET&#x27;,        timeout: 60000      &#125;,      config    )  )  // 初始化拦截器  this.interceptors = &#123;    request: new Interceptor(),    response: new Interceptor()  &#125;&#125;HttpRequest.prototype.request = function (config = &#123;&#125;) &#123;  const options = Object.assign(&#123;&#125;, this.config, config)  console.log(options)  let requestInterceptorChain = [],    responseInterceptorChain = []  // 推入请求拦截器  this.interceptors.request.forEach(obj =&gt; &#123;    requestInterceptorChain.unshift(obj.fulfilled, obj.rejected)  &#125;)  // 推入响应拦截器  this.interceptors.response.forEach(obj =&gt; &#123;    responseInterceptorChain.push(obj.fulfilled, obj.rejected)  &#125;)  let promise  // 第二个值为undefined是因为要为后面的请求进行补位 这样可以防止流入错误请求  let chain = [requestFn, undefined]  // request请求拦截插入最前方  Array.prototype.unshift.call(chain, ...requestInterceptorChain)  // responese响应插入最后方  chain = chain.concat(responseInterceptorChain)  promise = Promise.resolve(options)  // promise.then串行处理  while (chain.length) &#123;    promise = promise.then(chain.shift(), chain.shift())  &#125;  return promise&#125;// 不同请求格式的差异化处理callFor([&#x27;post&#x27;, &#x27;put&#x27;, &#x27;patch&#x27;], function (methodType) &#123;  HttpRequest.prototype[methodType] = function (url, data = &#123;&#125;, otherConfig = &#123;&#125;) &#123;    const config = Object.assign(&#123;&#125;, &#123; data, url, method: methodType &#125;, otherConfig)    return this.request(config)  &#125;&#125;)callFor([&#x27;delete&#x27;, &#x27;get&#x27;, &#x27;head&#x27;, &#x27;config&#x27;], function (methodType) &#123;  HttpRequest.prototype[methodType] = function (url, params = &#123;&#125;, otherConfig = &#123;&#125;) &#123;    const config = Object.assign(&#123;&#125;, otherConfig, &#123; url, params, method: methodType &#125;)    return this.request(config)  &#125;&#125;)export default HttpRequest\n\n这就是我基于 Prmiose 加小程序重复请求封装的核心代码，这里还未涉及到离开页面时的请求中断行为。不过大概思路的话就是收集所有请求的状态，封装成对象，调用时修改状态，后续有时间我会更加深究这部分的代码，更好地服务于业务。\n","slug":"uni-app微信小程序实现axios请求拦截器和重复请求中断","date":"2022-12-07T16:00:00.000Z","categories_index":"axios,微信小程序","tags_index":"uni-app,http,微信小程序","author_index":"谢小谢"},{"id":"8940855b891d4b3c9c870535631ad9ab","title":"StoryBook-为万表组件库提供文档说明","content":"前言对于公司级组件库来说，服务于业务的组件存在着参数较多，参数经常记不住问题。而且，脆弱的在线调试也为组件使用产生了很大的不便，好在出现了 StoryBook 这个神器，弥补了这个不足之处。\n为 Vue 使用 storybook，基于 Vue-cli 环境搭建\n\n\n\n\n\n\n\n\n集成 storybook 依赖\n1npx storybook init\n\n执行之后会在根目录生成storybook项目文件，如下图\n\n\n\n\n\n\n\n\n\n\n为你的组件库组件&#x2F;方法&#x2F;指令提供全局注册，继承 Vue 实例行为，修改.storybook&#x2F;preview.js\n12345678910111213141516export const parameters = &#123;  actions: &#123; argTypesRegex: &quot;^on[A-Z].*&quot; &#125;,  controls: &#123;    matchers: &#123;      color: /(background|color)$/i,      date: /Date$/,    &#125;,  &#125;,&#125;;import &#123; app &#125; from &quot;@storybook/vue3&quot;;// app相当于main.js文件中引入的Vue实例// Vue3示例操作，增加全局方法/变量app.config.globalProperties.OSS = config.OSS[&quot;production&quot;];app.config.globalProperties.OSS_STATIC = config.OSS.static;app.config.globalProperties.ERROR_IMG = config.PIC.errorPage;\n\n配置主入口，为 storybook 自有文件提供解析\n123456789101112131415161718192021222324const path = require(&quot;path&quot;);module.exports = &#123;  // glob模式匹配文件  stories: [&quot;../src/package/*/*.(js|jsx|ts|tsx)&quot;],  // 相关库支持  addons: [    &quot;@storybook/addon-links&quot;,    &quot;@storybook/addon-essentials&quot;,    &quot;@storybook/addon-interactions&quot;,    &quot;@storybook/preset-scss&quot;, // scss语法支持  ],  // 自定义webpack配置，相当于vue.config.js里面的configureWebpack选项  webpackFinal: async (config, &#123; configType &#125;) =&gt; &#123;    config.resolve.alias[&quot;@&quot;] = path.resolve(__dirname, &quot;../src&quot;);    config.resolve.alias[&quot;@wb-ui&quot;] = path.resolve(__dirname, &quot;../src&quot;);    return config;  &#125;,  // 依赖的主包  framework: &quot;@storybook/vue3&quot;,  core: &#123;    builder: &quot;@storybook/builder-webpack5&quot;,  &#125;,&#125;;\n\n\n\n\n\n\n\n\n\n\n修改文件模板行为，配置你的组件样式，居中显示\n细心的你在预览的时候可能会看到下面的情况，预览始终不居中\n\n增加 preview-body.html\n1234567&lt;style&gt;  #root &#123;    display: flex;    justify-content: center;    align-items: center;  &#125;&lt;/style&gt;\n\n\n\n\n\n\n\n\n\n\n为业务组件增加 iconfont 支持\n万表相关组件是使用的阿里字体图标，在.storybook 文件夹下增加 preview-head.html\n1&lt;link rel=&quot;stylesheet&quot; href=&quot;//at.alicdn.com/t/link.css&quot; /&gt;\n\n\n\n\n\n\n\n\n\n\n为组件编写组件描述文件\n官方文档参考：https://storybook.js.org/docs/vue/writing-stories/introduction\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 引入组件import WbList from &quot;./index&quot;;import &#123; Meta, StoryFn &#125; from &quot;@storybook/vue3&quot;;export default &#123;  // 组件名称  title: &quot;wb-list&quot;,  // 组件实例  component: WbList,  // 编辑props描述  argTypes: &#123;    status: &#123;      description:        &quot;状态常量 NO_MORE: 没有更多/LOAD：加载中/END：到底/ERROR：错误&quot;,      required: true,    &#125;,    total: &#123;      description: &quot;数据总体长度&quot;,    &#125;,    enableFlex: &#123;      description: &quot;是否开启flex布局&quot;,    &#125;,    emptyText: &#123;      description: &quot;数据为空时的文本&quot;,    &#125;,    emptyStyle: &#123;      description: &quot;数据为空时的文本样式&quot;,    &#125;,    emptyImageStyle: &#123;      description: &quot;数据为空时的图片样式&quot;,    &#125;,  &#125;,&#125; as Meta&lt;typeof WbList&gt;;// 配置显示模板const Template: StoryFn&lt;typeof WbList&gt; = (args) =&gt; (&#123;  components: &#123; WbList &#125;,  setup() &#123;    return &#123; args &#125;;  &#125;,  template: `&lt;wb-list v-bind=&quot;args&quot; :status=&quot;status&quot; :total=&quot;0&quot; enable-flex &gt;    &lt;div style=&quot;width:200px;height:200px;background: red;margin-right:10px;&quot; v-for=&quot;item in [1, 2, 3, 4]&quot; :key=&quot;item&quot;&gt;213&lt;/div&gt;  &lt;/wb-list&gt;`,&#125;);Template.storyName = &quot;图片组件&quot;;// 配置组件的不同状态export const Normal = Template.bind(&#123;&#125;);Normal.args = &#123;  status: &quot;LOAD&quot;,  total: 100,&#125;;\n\n\n\n\n\n\n\n\n\n\n打包 storybook 项目\n1npm run build-storybook\n","slug":"StoryBook-为万表组件库提供文档说明","date":"2022-11-22T16:00:00.000Z","categories_index":"经验,Vue","tags_index":"Vue,组件库","author_index":"谢小谢"},{"id":"4ef67a396b8d10d036cface974a81940","title":"记一次多页面配置后CDN配置失效问题，查看cli源码并解决问题","content":"某天的某天，产品总监突然给我一个任务，让我在主站加一个页面。由于主站之前已经是 nodeJs 了，在原有基础上进行原生页面编写费时费力，且没有很大的 SEO 需求。所以我使用了上次商家入驻，在 Vue3 SPA 原来的基础上进行多页面开发。\nSPA 多页面配置的好处\n共享项目逻辑：作为新增加的页面，可以无缝地使用之前不相关业务的基建逻辑，如公用封装方法等。\nchunk 分离，业务分离，减少包大小：如果是在单入口的情况下增加一个新的路由，在主入口的 js 文件中势必会带上原有的部分业务逻辑，组件等。这样会增加请求时的包大小。\n自定义入口 TDK 有效，SEO 优化更精确\n\n开始配置这里主要是通过 vue.config.js 入口进行配置\n1234567891011121314151617181920212223242526272829303132// vue.config.js增加新配置项pages: &#123;  // 旧的商家入驻入口  index: &#123;    entry: &#x27;src/main.ts&#x27;,    template: &#x27;public/index.html&#x27;,    filename: &#x27;index.html&#x27;,    title: &#x27;Index Page&#x27;,    chunks: [&#x27;chunk-vendors&#x27;, &#x27;chunk-common&#x27;, &#x27;index&#x27;]  &#125;,  share: &#123;    entry: &#x27;src/share.ts&#x27;,    template: &#x27;public/share.html&#x27;,    filename: &#x27;share.html&#x27;,    title: &#x27;&#x27;,    chunks: [&#x27;chunk-vendors&#x27;, &#x27;chunk-common&#x27;, &#x27;share&#x27;]  &#125;&#125;,chainWebpack: config =&gt; &#123;  const cdn = &#123; .... &#125;  config    .plugin(&#x27;html&#x27;)    .use(HtmlWebpackPlugin)    .tap(args =&gt; &#123;      console.log(args);      args[0].cdn = cdn      args[0].chunksSortMode = &#x27;none&#x27;      // args.cdn = assetsCDN.assets;      return args    &#125;)&#125;\n\n当我信誓旦旦地准备看到绿色打印时，却报了一个 **TypeError: Cannot set properties of undefined (setting ‘cdn’)**的错误，于是，我打印了 args 的值，发现打印出来了一个空的数组。此时我做了一个猜想，重新使用了 HtmlWebpackPlugin 插件，会不会导致原有的配置被清空？\n带着疑问解决问题。于是，我看了看 vue-cli4 的源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130// 当我们运行vue-cli-service run serve 相当于直接调用以下指令new Service(...).run(&#x27;serve&#x27;)// 下面是主要运行过程的简化版代码module.exports = class Service &#123;  constructor (context, &#123; plugins, pkg, inlineOptions, useBuiltIn &#125; = &#123;&#125;) &#123;    process.VUE_CLI_SERVICE = this    // 初始化chainWebpack链式调用配置，存储所有的chainWebapck配置链    this.webpackChainFns = []    // 初始化webpackConfigure配置    this.webpackRawConfigFns = []    // 初始化所有的webpackChain链式    this.plugins = this.resolvePlugins(plugins, useBuiltIn)  &#125;  async run (name, args = &#123;&#125;, rawArgv = []) &#123;    this.init()    // 当指令为serve时 其实是调用了/vue-cli-4/packages/@vue/cli-service/lib/commands/serve.js里面的运行逻辑    const &#123; fn &#125; = command    return fn(args, rawArgv)  &#125;  init(mode) &#123;    // 应用所有plugins数组的插件插件    this.plugins.forEach((&#123; id, apply &#125;) =&gt; &#123;      if (this.pluginsToSkip.has(id)) return      apply(new PluginAPI(id, this), this.projectOptions)    &#125;)    if (this.projectOptions.chainWebpack) &#123;      this.webpackChainFns.push(this.projectOptions.chainWebpack)    &#125;  &#125;  resolvePlugins (inlinePlugins, useBuiltIn) &#123;    const idToPlugin = id =&gt; (&#123;      id: id.replace(/^.\\//, &#x27;built-in:&#x27;),      apply: require(id)    &#125;)    let plugins    // 每一个内置的js都按顺序require一次    const builtInPlugins = [      &#x27;./commands/serve&#x27;,      &#x27;...&#x27;, // 其他插件省略      &#x27;./config/app&#x27;    ].map(idToPlugin)    // 引入所有的内置插件文件，最后存储在this.plugins数组里面    const projectPlugins = Object.keys(this.pkg.devDependencies || &#123;&#125;)      .concat(Object.keys(this.pkg.dependencies || &#123;&#125;))      .filter(isPlugin)      .map(id =&gt; &#123;        if (          this.pkg.optionalDependencies &amp;&amp;          id in this.pkg.optionalDependencies        ) &#123;          let apply = () =&gt; &#123;&#125;          try &#123;            apply = require(id)          &#125; catch (e) &#123;            warn(`Optional dependency $&#123;id&#125; is not installed.`)          &#125;          return &#123; id, apply &#125;        &#125; else &#123;          return idToPlugin(id)        &#125;      &#125;)    plugins = builtInPlugins.concat(projectPlugins)    return plugins  &#125;  // 解析webpackChain  resolveChainableWebpackConfig () &#123;    const chainableConfig = new Config()    // config作为实例，链式调用所有方法，应用所有WebpackChain配置    this.webpackChainFns.forEach(fn =&gt; fn(chainableConfig))    return te  &#125;  // 在混合/vue-cli-4/packages/@vue/cli-service/lib/commands下的所有配置  resolveWebpackConfig (chainableConfig = this.resolveChainableWebpackConfig()) &#123;    // 所有chainWebpack配置初始化成webpackCompiler(options)模式    let config = chainableConfig.toConfig()    const original = config    // 和configureWebapck混合    this.webpackRawConfigFns.forEach(fn =&gt; &#123;      if (typeof fn === &#x27;function&#x27;) &#123;        // function with optional return value        const res = fn(config)        if (res) config = merge(config, res)      &#125; else if (fn) &#123;        // merge literal values        config = merge(config, fn)      &#125;    &#125;)    return config  &#125;&#125;// packages/@vue/cli-service/lib/PluginAPI.jsclass PluginAPI &#123;  constructor (id, service) &#123;    this.id = id    this.service = service  &#125;  resolveWebpackConfig (chainableConfig) &#123;    return this.service.resolveWebpackConfig(chainableConfig)  &#125;  chainWebpack (fn) &#123;    this.service.webpackChainFns.push(fn)  &#125;&#125;// vue-cli4/packages/@vue/cli-service/lib/commands/serve.js// 上面Sevice类的run方法最终调用了当前类的serve方法，在这里调用了新增Plugins的resolveWebpackConfig// 也就是Service类的resolveWebpackConfig方法module.exports = (api, options) =&gt; &#123;  api.registerCommand(&#x27;serve&#x27;, &#123;    ...    &#125;  &#125;, async function serve (args) &#123;    // resolve webpack config    const webpackConfig = api.resolveWebpackConfig()  &#125;)&#125;module.exports.defaultModes = &#123;  serve: &#x27;development&#x27;&#125;\n\n从上面代码就可以分析到，vue-cli 是按以下顺序来执行的，\n\nVue-cli 初始化时会使用所有&#x2F;cli-service&#x2F;lib&#x2F;commands，&#x2F;cli-service&#x2F;lib&#x2F;config 内的顺序来获取 webpackChain 的配置，塞入 Service 实例的 webpackChainFns 中。\n&#x2F;cli-service&#x2F;lib&#x2F;commands 内的插件一般是作为运行插件的，并不会像&#x2F;cli-service&#x2F;lib&#x2F;commands 内的插件一样，一直接调用就直接塞入 webpackChainFns，而是在 Plugins 具体调用内部函数的 registerCommand(‘serve’)注册为启动函数后，才会最终调用。\n我们在 vue.config.js 配置的 webpackChain 配置在代码逻辑中是在&#x2F;cli-service&#x2F;lib&#x2F;config 的 webpackChain 配置收集完才推入 webpackChainFns 中，这也印证了为什么我们的 html-webpack-plugin 配置之后，原来的多页&#x2F;单页配置会被覆盖掉。\n\n解决办法说了这么多，那究竟该怎么配置呢，有 2 种办法。\n\n一种就是在原来的 pages 项上加入 cdn 这个 key\n\n123456789101112131415161718192021222324252627282930// vue.config.js增加新配置项module.exports = &#123;  pages: &#123;    // 旧的商家入驻入口    index: &#123;      entry: &quot;src/main.ts&quot;,      ...其他参数省略,      cdn: &#123;        js: [          &quot;https://static.wbiao.co/libs/cdn/vue.global@3.0.11.js&quot;,          &quot;https://static.wbiao.co/libs/cdn/vue-router.global@4.0.6.js&quot;,          &quot;https://static.wbiao.co/libs/cdn/vuex.global@4.0.0.js&quot;,          &quot;https://static.wbiao.co/libs/cdn/axios.min.js&quot;,        ],      &#125;,    &#125;,    share: &#123;      entry: &quot;src/share.ts&quot;,      ...其他参数省略,      cdn: &#123;        js: [          &quot;https://static.wbiao.co/libs/cdn/vue.global@3.0.11.js&quot;,          &quot;https://static.wbiao.co/libs/cdn/vue-router.global@4.0.6.js&quot;,          &quot;https://static.wbiao.co/libs/cdn/vuex.global@4.0.0.js&quot;,          &quot;https://static.wbiao.co/libs/cdn/axios.min.js&quot;,        ],      &#125;,    &#125;,  &#125;,&#125;;\n\n\n第二种种就是重写 html-webpack-plugins 的 entry 的模板配置\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253module.exports = &#123;  pages: &#123;    index: &#123;      entry: &quot;src/main.ts&quot;,      chunks: [&quot;chunk-vendors&quot;, &quot;chunk-common&quot;, &quot;index&quot;],    &#125;,    share: &#123;      entry: &quot;src/share.ts&quot;,      chunks: [&quot;chunk-vendors&quot;, &quot;chunk-common&quot;, &quot;share&quot;],    &#125;,  &#125;,  chainWebpack: (config) =&gt; &#123;    const cdn = &#123;      js: [        &quot;https://static.wbiao.co/libs/cdn/vue.global@3.0.11.js&quot;,        &quot;https://static.wbiao.co/libs/cdn/vue-router.global@4.0.6.js&quot;,        &quot;https://static.wbiao.co/libs/cdn/vuex.global@4.0.0.js&quot;,        &quot;https://static.wbiao.co/libs/cdn/axios.min.js&quot;,      ],    &#125;;    config      .plugin(&quot;html&quot;)      .use(HtmlWebpackPlugin)      .tap((args) =&gt; &#123;        args[0] = &#123;          title: &quot;wanbiao&quot;,          cdn: cdn,          minify: &#123;            removeComments: true,            collapseWhitespace: true,            collapseBooleanAttributes: true,            removeScriptTypeAttributes: true,          &#125;,          template: path.resolve(__dirname, &quot;./public/index.html&quot;),        &#125;;        args[1] = &#123;          title: &quot;wb2&quot;,          cdn: cdn,          minify: &#123;            removeComments: true,            collapseWhitespace: true,            collapseBooleanAttributes: true,            removeScriptTypeAttributes: true,          &#125;,          template: path.resolve(__dirname, &quot;./public/share.html&quot;),        &#125;;        args[0].cdn = cdn;        args[0].chunksSortMode = &quot;none&quot;;        // args.cdn = assetsCDN.assets;        return args;      &#125;);  &#125;,&#125;;\n\n基础模板展示1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot; /&gt;    &lt;meta name=&quot;force-rendering&quot; content=&quot;webkit&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot; /&gt;    &lt;link rel=&quot;icon&quot; href=&quot;/favicon.ico&quot; /&gt;    &lt;title&gt;&lt;%= process.env.VUE_APP_TITLE %&gt;&lt;/title&gt;    &lt;!-- 使用CDN的CSS文件 --&gt;    &lt;% for (var i in htmlWebpackPlugin.options.cdn &amp;&amp;    htmlWebpackPlugin.options.cdn.css) &#123; %&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%= htmlWebpackPlugin.options.cdn.css[i] %&gt;&quot; /&gt;    &lt;% &#125; %&gt;    &lt;!-- 使用CDN的JS文件 --&gt;    &lt;% for (var i in htmlWebpackPlugin.options.cdn &amp;&amp;    htmlWebpackPlugin.options.cdn.js) &#123; %&gt;    &lt;script      type=&quot;text/javascript&quot;      src=&quot;&lt;%= htmlWebpackPlugin.options.cdn.js[i] %&gt;&quot;    &gt;&lt;/script&gt;    &lt;% &#125; %&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;noscript&gt;      &lt;strong        &gt;We&#x27;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&#x27;t work        properly without JavaScript enabled. Please enable it to        continue.&lt;/strong      &gt;    &lt;/noscript&gt;    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;    &lt;!-- built files will be auto injected --&gt;  &lt;/body&gt;&lt;/html&gt;\n","slug":"记一次多页面配置后CDN配置失效问题，查看cli源码并解决问题","date":"2022-03-13T16:00:00.000Z","categories_index":"经验,单页应用","tags_index":"vue,单页应用","author_index":"谢小谢"},{"id":"18236e9a0226f101897836af69d7e11a","title":"Webpack4优化之依赖包cdn加载优化","content":"记录一下自己项目使用 cdn 加速的具体过程，就是分离外部库的包(包括 vue, vue-router, vuex 等)，尽量只保留主要逻辑\n准备工作首先确定一下哪些包需要进行分离，这里我们主要 Vue 的周边库，利用 html-plugin-webpack 插件，插入到 script 标签之中\n开始配置 webpack首先配置 html-webpack-plugin 和 webpack 的 externals 属性，防止打包时将要分离的库一起打包进去，这里使用 chainWebpack 插件，\n12345678910111213const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);config.externals(&#123; vue: &quot;Vue&quot;, &quot;vue-router&quot;: &quot;VueRouter&quot;, vuex: &quot;Vuex&quot; &#125;);config.plugin(&quot;html-webpack-plugin&quot;).use(  new HtmlWebpackPlugin(&#123;    cdnJsModule: [      &quot;https://lib.baomitu.com/vue/3.0.7/vue.runtime.global.js&quot;,      &quot;https://lib.baomitu.com/vue-router/4.0.4/vue-router.global.prod.js&quot;,      &quot;https://lib.baomitu.com/vuex/4.0.0/vuex.global.prod.min.js&quot;,    ],    template: &quot;template/loading.html&quot;, // 重写div=app  &#125;));\n\n可以看到 htmlwebpackplugin 配置了 cdnjsModule 这个属性，后续在定制的 loading.html 模板里面写入\n123456789&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot; /&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;&lt;% for (var i in htmlWebpackPlugin.options.cdnJsModule) &#123; %&gt;&lt;script src=&quot;&lt;%= htmlWebpackPlugin.options.cdnJsModule[i] %&gt;&quot;&gt;&lt;/script&gt;&lt;% &#125; %&gt;&lt;/head&gt; ...\n\n打包对比 现在看看，配置前后的打包情况，可见减少了差不多 100K 左右的大小1234567// 未配置前server/js/chunk-vendors.3e815d2d.js 144.96 KiB   52.24 KiBserver/js/app.3ad30f1e.js 46.88 KiB        12.06 KiB// 配置后server/js/app.941edfa5.js   50.58 KiB 12.30 KiBserver/js/chunk-vendors.0c15f71f.js    50.22 KiB    18.02 KiB\n","slug":"Webpack4优化之依赖包cdn加载优化","date":"2022-03-04T16:00:00.000Z","categories_index":"webpack,总结,Vue","tags_index":"webpack","author_index":"谢小谢"},{"id":"8244f2f98fb7537fa6df6a08feffa028","title":"Vue3源码 实例初始化过程详解","content":"自己接触 Vue3 也有一段时间了 之前一直有看相关的源码，现在总结下 creatApp 到 mount 挂载中间发生了什么\n\n\n\n\n\n\n\n\n\n下面的代码均为精简版 删掉了部分不相关的代码\n查看入口文档123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158// vue-next/packages/runtime-dom/src/index.ts/*   nodeOps: packages/runtime-dom/src/nodeOps.ts   patchProp: packages/runtime-dom/src/patchProp.ts   renderOptions为 合并nodeOps和patchProp对象， 为后面vnode的patch操作提供一系列更新dom和内部属性的方法 */const rendererOptions = extend(&#123; patchProp, forcePatchProp &#125;, nodeOps)  let renderer: Renderer&lt;Element&gt; | HydrationRenderer/*   1.判断renderer值 实质上是执行了 packages/runtime-core/src/renderer.ts的 baseCreateRenderer里面所返回对象的里面的createApp方法 */function ensureRenderer() &#123;   return renderer || (renderer = createRenderer&lt;Node, Element&gt;(rendererOptions)) &#125;// 标准化组件function normalizeContainer(  container: Element | ShadowRoot | string ): Element | null &#123;  if (isString(container)) &#123;    const res = document.querySelector(container)    if (__DEV__ &amp;&amp; !res) &#123;      warn(`Failed to mount app: mount target selector &quot;$&#123;container&#125;&quot; returned null.`)    &#125;    return res  &#125;  return container as any&#125;export const createApp = (...args) =&gt; &#123;  // 实际调用了packages/runtime-core/src/apiCreateApp.ts的createAppAPI方法(柯里化函数)返回的createApp  const app = ensureRenderer().createApp(...args);  const &#123; mount &#125; = app;  app.mount = (containerOrSelector: Element | ShadowRoot | string): any =&gt; &#123;    // 判断是否是真实的dom 如果不是就通过document.querySelector获取    // 找不到就会报警告    const container = normalizeContainer(containerOrSelector);    // 没有找到dom节点就直接退出函数    if (!container) return;    const component = app._component;    if (!isFunction(component) &amp;&amp; !component.render &amp;&amp; !component.template) &#123;      component.template = container.innerHTML;    &#125;    // 挂载前清空内容    container.innerHTML = &quot;&quot;;    // 执行挂载dom操作    const proxy = mount(container);    if (container instanceof Element) &#123;      container.removeAttribute(&quot;v-cloak&quot;);      container.setAttribute(&quot;data-v-app&quot;, &quot;&quot;);    &#125;    // 返回vnode的proxy对象    return proxy;  &#125;;&#125;;export function createAppContext(): AppContext &#123;  return &#123;    app: null as any,    config: &#123;      isNativeTag: NO,      performance: false,      globalProperties: &#123;&#125;,      optionMergeStrategies: &#123;&#125;,      isCustomElement: NO,      errorHandler: undefined,      warnHandler: undefined,    &#125;,    mixins: [],    components: &#123;&#125;,    directives: &#123;&#125;,    provides: Object.create(null),  &#125;;&#125;export function createAppAPI&lt;HostElement&gt;(   render: RootRenderFunction,   hydrate?: RootHydrateFunction ): CreateAppFunction&lt;HostElement&gt; &#123;  // 返回一个app实例对象  const context = createAppContext()  // 创建一个存储所有插件的数组  const installedPlugins = new Set()  // 当前dom是否已经挂载  let isMounted = false  // 初始化app实例  const app: App = (context.app = &#123;    _uid: uid++,      _component: rootComponent as ConcreteComponent,      _props: rootProps,      _container: null,      _context: context,      version,      get config() &#123;        return context.config      &#125;  &#125;);  // 初始化use方法 供插件使用  use(plugin: Plugin, options: any[]) &#123;&#125;    component(name: string, component?: Component): any &#123;    if (__DEV__) &#123;      validateComponentName(name, context.config);    &#125;    if (!component) &#123;      return context.components[name];    &#125;    if (__DEV__ &amp;&amp; context.components[name]) &#123;      warn(`Component &quot;$&#123;name&#125;&quot; has already been registered in target app.`);    &#125;    // 添加到执行上下文    context.components[name] = component;    return app;  &#125;,  // 初始化全局指令方法  directive(name: string, directive?: Directive) &#123;    if (__DEV__) &#123;      validateDirectiveName(name);    &#125;    if (!directive) &#123;      return context.directives[name] as any;    &#125;    // 添加到执行上下文    context.directives[name] = directive;    return app;  &#125;,  // 初始化实例写在方法  unmount() &#123;    if (isMounted) &#123;      // 清空节点      render(null, app._container);      if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123;        devtoolsUnmountApp(app);      &#125;    &#125;  &#125;,  // 根实例提供方法注入  provide(key, value) &#123;    context.provides[key as string] = value;    return app;  &#125;,  // 初始化节点挂载  mount(rootContainer: HostElement, isHydrate?: boolean): any &#123;    // 没有挂载情况下会根据传入的组件创建vnode节点    if (!isMounted) &#123;      const vnode = createVNode(        // createApp传进来的组件创建了一个虚拟dom        rootComponent as ConcreteComponent,        rootProps      );      vnode.appContext = context;      // 是否是服务端渲染      if (isHydrate &amp;&amp; hydrate) &#123;      &#125; else &#123;        // 如果不是服务端渲染的话 调用渲染函数渲染到挂载dom里面        render(vnode, rootContainer);      &#125;      // 挂载标识改变      isMounted = true;      // app实例 创建挂载点标识      app._container = rootContainer;      // for devtools and telemetry      (rootContainer as any).__vue_app__ = app;      if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123;        devtoolsInitApp(app, version);      &#125;      return vnode.component!.proxy;    &#125; else if (__DEV__) &#123;      // 开发环境下重复挂载报警    &#125;  &#125;&#125;\n\n总结\n\n\n\n\n\n\n\n\n从上图可知, ensureRenderer().createApp(…args)实际上直接调用了 createAppAPI 的 createApp 后，重写了 app 的 mount 方法，至于为什么要重写 mount 方法，主要还是应对后面的跨平台改造，mount 作为一个独立的跨平台处理函数，不应该带有特定的平台的逻辑，而这里仅仅针对 web，挂载前清空容器内容则是为了防止其他异常情况导致保存了该段代码，那么下面就分析下 createApp 做了什么 下面是主要源码注释\n1// packages/runtime-core/src/apiCreateApp.ts\n\n总结\n\n\n\n\n\n\n\n\ncreateApp 里面创建了 context 实例，并且为 context 里面的 app 属性初始化了 use 方法提供全局插件挂载，mixin 方法提供全局逻辑混入，component 方法提供全局组件注册，directive 提供全局指令注册，mount,unmount 提供组件挂载&#x2F;卸载功能等。同时将这个 4 个方法赋予 context,将 contxt 自己挂载在 app 属性的\\_context 执行上下文中，并将其赋值给了一个新的 app 常量返回出去, mount 方法里面执行了 vnode 建立 &#x3D;&gt; vnode 渲染的过程，最终交给 render 函数通过底层的 dom 操作插入到 rootContainer 里面，至于 render 函数的详细执行过程，给我一点时间整理。\n","slug":"Vue3源码 实例初始化过程详解","date":"2022-02-23T16:00:00.000Z","categories_index":"Vue,总结,Vue源码","tags_index":"Vue3","author_index":"谢小谢"},{"id":"b5ff54a9d086ee4b944aa5321b46f563","title":"Vue2.6系列源码解析之Keep-Alive组件的缓存逻辑","content":"对于很多用过 vue 这个框架的人来说，想必都用过 keep-alive 组件缓存功能。vue 内部使用了 LRU 缓存淘汰算法来实现组件的缓存更新问题，那 vue 是如何实现这个 keep-alive 组件的逻辑呢，我们来解析一下。\n源码解读123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153// 获取vnode实例名称function getComponentName(opts: ?VNodeComponentOptions): ?string &#123;  return opts &amp;&amp; (opts.Ctor.options.name || opts.tag);&#125;// 匹配当前队列里面是否存在该vnodefunction matches(  pattern: string | RegExp | Array&lt;string&gt;,  name: string): boolean &#123;  if (Array.isArray(pattern)) &#123;    return pattern.indexOf(name) &gt; -1;  &#125; else if (typeof pattern === &quot;string&quot;) &#123;    return pattern.split(&quot;,&quot;).indexOf(name) &gt; -1;  &#125; else if (isRegExp(pattern)) &#123;    return pattern.test(name);  &#125;  return false;&#125;// 实例筛选function pruneCache(keepAliveInstance: any, filter: Function) &#123;  const &#123; cache, keys, _vnode &#125; = keepAliveInstance;  for (const key in cache) &#123;    const entry: ?CacheEntry = cache[key];    if (entry) &#123;      const name: ?string = entry.name;      if (name &amp;&amp; !filter(name)) &#123;        pruneCacheEntry(cache, key, keys, _vnode);      &#125;    &#125;  &#125;&#125;function pruneCacheEntry(  cache: CacheEntryMap,  key: string,  keys: Array&lt;string&gt;,  current?: VNode) &#123;  const entry: ?CacheEntry = cache[key];  if (entry &amp;&amp; (!current || entry.tag !== current.tag)) &#123;    entry.componentInstance.$destroy();  &#125;  cache[key] = null;  remove(keys, key);&#125;export default &#123;  name: &quot;keep-alive&quot;,  abstract: true,  props: &#123;    include: patternTypes,    exclude: patternTypes,    max: [String, Number],  &#125;,  methods: &#123;    // 虚拟dom缓存    cacheVNode() &#123;      const &#123; cache, keys, vnodeToCache, keyToCache &#125; = this;      // 如果存在等待被缓存的vnode 就要缓存起来      if (vnodeToCache) &#123;        const &#123; tag, componentInstance, componentOptions &#125; = vnodeToCache;        cache[keyToCache] = &#123;          name: getComponentName(componentOptions),          tag,          componentInstance,        &#125;;        // 推vnode的key进入缓存组        keys.push(keyToCache);        // 如果缓存组件有最大数量限制的情况下 并且超大最大缓存数量限制，那么就删除缓存队列的第一项        // pruneCacheEntry 判断了当前的缓存队列的第一项是 如果跟新进来的最新vnode是否一致，        // 不一致的情况下就直接卸载当前第一项的实例，一致就保存不进行卸载进行复用操作        if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) &#123;          pruneCacheEntry(cache, keys[0], keys, this._vnode);        &#125;        this.vnodeToCache = null;      &#125;    &#125;,  &#125;,  created() &#123;    // 存储所有组件    this.cache = Object.create(null);    // 存储所有组件的cid值 源码里面是逐步递增的    this.keys = [];  &#125;,  destroyed() &#123;    // 卸载时删除所有缓存的组件实例    for (const key in this.cache) &#123;      pruneCacheEntry(this.cache, key, this.keys);    &#125;  &#125;,  mounted() &#123;    // 开始缓存当前实例    this.cacheVNode();    // 监听include和exclude队列，去除里面不匹配的的组件    this.$watch(&quot;include&quot;, (val) =&gt; &#123;      pruneCache(this, (name) =&gt; matches(val, name));    &#125;);    this.$watch(&quot;exclude&quot;, (val) =&gt; &#123;      pruneCache(this, (name) =&gt; !matches(val, name));    &#125;);  &#125;,  updated() &#123;    // 更新的时候同步更新当前vnode    this.cacheVNode();  &#125;,  render() &#123;    const slot = this.$slots.default;    const vnode: VNode = getFirstComponentChild(slot);    const componentOptions: ?VNodeComponentOptions =      vnode &amp;&amp; vnode.componentOptions;    // 如果存在组件实例    if (componentOptions) &#123;      // check pattern      const name: ?string = getComponentName(componentOptions);      const &#123; include, exclude &#125; = this;      // 如果不缓存的列表有当前vnode或者缓存列表没有当前vnode 那么就直接返回该节点      if (        (include &amp;&amp; (!name || !matches(include, name))) ||        (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))      ) &#123;        return vnode;      &#125;      // 到这里就说明当前组件是需要缓存的      const &#123; cache, keys &#125; = this;      const key: ?string =        vnode.key == null          ? componentOptions.Ctor.cid +            (componentOptions.tag ? `::$&#123;componentOptions.tag&#125;` : &quot;&quot;)          : vnode.key;      // 如果当前组件被缓存过 那么就更新当前组件 把组件推到缓存队列key的最后边，      // 这样就能总是获取到最新的更新项 LRU算法      if (cache[key]) &#123;        // 复用缓存        vnode.componentInstance = cache[key].componentInstance;        remove(keys, key);        keys.push(key);      &#125; else &#123;        this.vnodeToCache = vnode;        this.keyToCache = key;      &#125;      vnode.data.keepAlive = true;    &#125;    return vnode || (slot &amp;&amp; slot[0]);  &#125;,&#125;;\n\n说说 LRU 缓存淘汰算法LRU 算法，即最近最久未使用，是一种非常常见的缓存淘汰算法。算法的设计原则： 如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。\n下面是我自己画的 keep-alive 缓存淘汰算法的流程示意图例，辅助查看\n\n","slug":"Vue2.6系列源码解析之Keep-Alive组件的缓存逻辑2022-02-03","date":"2022-02-02T16:00:00.000Z","categories_index":"Vue,总结,Vue源码","tags_index":"Vue","author_index":"谢小谢"},{"id":"d808854a301e8b255f9b814d0115997a","title":"Vue2.6源码解析之diff算法更新过程及其相关问题","content":"每次面试都会被面试官问到 diff 算法，每次都看别人文章，过了就忘。最近抽空自己看看源码，自己在不借助其他人文章思路的情况下，自己死磕源码，总结出自己的一些心得，ps：下次再也不用一直找别人文章看\n从问题说起？\ndiff 算法是怎么对比的？\n遇到了 v-for 绑定的 key 值为 index 导致删除列表的某一项，删除的却是始终是最后一项的情况。\n没绑定 index，删除后也会出现始终删除最后一项的问题。\n官网说的默认使用旧地复用在哪里体现？\n\n具体看下图代码\n123456789101112131415161718192021222324252627282930313233343536373839404142&lt;div class=&quot;content-body&quot;&gt;  &lt;ul&gt;    &lt;li v-for=&quot;(item,index) in selectionConditionList&quot; :key=&quot;index&quot;&gt;      &lt;v-selection-condition-list&gt;&lt;/v-selection-condition-list&gt;      &lt;button @click=&quot;deleteSelectionCondition(index)&quot;&gt;删除&lt;/button&gt;    &lt;/li&gt;  &lt;/ul&gt;  &lt;button @click=&quot;addNewSelectionTask&quot;&gt;新建任务&lt;/button&gt;&lt;/div&gt;&lt;script&gt;  const vSelectionConditionList = &#123;    data() &#123;      return &#123;        inputName: Math.random(),      &#125;;    &#125;,    template: `&lt;input type=&quot;text&quot; :value=&quot;inputName&quot;&gt;`,  &#125;;  var app = new Vue(&#123;    el: &quot;.content-body&quot;,    data() &#123;      return &#123;        selectionConditionList: [],      &#125;;    &#125;,    methods: &#123;      // 添加      addNewSelectionTask() &#123;        this.selectionConditionList.push(&#123;&#125;);      &#125;,      // 删除      deleteSelectionCondition(index) &#123;        console.log(&quot;delete..&quot; + index);        this.selectionConditionList.splice(index, 1);      &#125;,    &#125;,    components: &#123;      vSelectionConditionList,    &#125;,  &#125;);&lt;/script&gt;\n\n解决问题先看看源码下面代码会去掉一些非核心的代码\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165// src/core/vdom/patch.jsfunction updateChildren(  parentElm,  oldCh,  newCh,  insertedVnodeQueue,  removeOnly) &#123;  let oldStartIdx = 0; // 旧起始标记 默认0  let newStartIdx = 0; // 新起始标记 默认0  let oldEndIdx = oldCh.length - 1; // 旧的最后一个的索引  let oldStartVnode = oldCh[0]; // 旧的第一个节点  let oldEndVnode = oldCh[oldEndIdx]; // 旧的最后一个节点  let newEndIdx = newCh.length - 1; // 新的最后一个的索引  let newStartVnode = newCh[0]; // 新的第一个节点  let newEndVnode = newCh[newEndIdx]; // 新的最后一个节点  let oldKeyToIdx, idxInOld, vnodeToMove, refElm;  // removeOnly是一个特殊标志，仅由&lt;transition group&gt;使用，以确保在离开转换期间被删除的元素保持在正确的相对位置  const canMove = !removeOnly;  // 判断新节点是否存在重复的key  if (process.env.NODE_ENV !== &quot;production&quot;) &#123;    checkDuplicateKeys(newCh);  &#125;  // 起始对比  // 当旧起始index小于等于旧的旧的结束index 并且 新起始小于等于新结束index  while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;    // 如果旧起始节点未定义    if (isUndef(oldStartVnode)) &#123;      // 旧起始节点下标进1位 +1      oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left    &#125; else if (isUndef(oldEndVnode)) &#123;      // 如果旧的结束节点未定义 那么下标就退一位 -1      oldEndVnode = oldCh[--oldEndIdx];    &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123;      // 如果新旧起始节点是同个节点 那么就进行下一层的对比 并且两者下标都进一位 +1      patchVnode(        oldStartVnode,        newStartVnode,        insertedVnodeQueue,        newCh,        newStartIdx      );      oldStartVnode = oldCh[++oldStartIdx];      newStartVnode = newCh[++newStartIdx];    &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123;      // 如果新旧结束节点是同个节点 那么就进行下一层的对比 并且两者下标都退一位 1      patchVnode(        oldEndVnode,        newEndVnode,        insertedVnodeQueue,        newCh,        newEndIdx      );      oldEndVnode = oldCh[--oldEndIdx];      newEndVnode = newCh[--newEndIdx];    &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123;      // 如果旧起始节点和新结束是同个节点，那么进行下一层对比 旧起始进一位+1 新起始节点退一位-1      // 并且把 那么就把旧起始节点插入到旧结束节点的前面      // Vnode moved right      patchVnode(        oldStartVnode,        newEndVnode,        insertedVnodeQueue,        newCh,        newEndIdx      );      canMove &amp;&amp;        nodeOps.insertBefore(          parentElm,          oldStartVnode.elm,          nodeOps.nextSibling(oldEndVnode.elm)        );      oldStartVnode = oldCh[++oldStartIdx];      newEndVnode = newCh[--newEndIdx];    &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123;      // 如果旧结束和新起始是同个节点，那么进行下一层对比 旧结束退一位-1 新起始节点进一位+1      // 并且把 那么就把旧起始节点插入到旧结束节点的位置      // Vnode moved left      patchVnode(        oldEndVnode,        newStartVnode,        insertedVnodeQueue,        newCh,        newStartIdx      );      canMove &amp;&amp;        nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);      oldEndVnode = oldCh[--oldEndIdx];      newStartVnode = newCh[++newStartIdx];    &#125; else &#123;      // 如果旧数据没有绑定key值      if (isUndef(oldKeyToIdx))        // oldKeyToIdx存储当前旧数据区间的key值为key当前的索引        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);      // 如果当前新数据有key的话  idxInOld就等于oldKeyToIdx的key项的索引      // findIdxInOld拿当前新开始节点，通过判断旧起始-结束节点之中有没有其位置，找出当前新开始在旧中的位置      // 无key情况下      //    如果新节点不存在于旧节点中，那么就作为新增节点加入插入到oldStartNode前面      // 有key情况下 直接获取当前节点在旧的之前的位置      idxInOld = isDef(newStartVnode.key)        ? oldKeyToIdx[newStartVnode.key]        : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);      // 如果如果没有index 那么就直接创建元素      if (isUndef(idxInOld)) &#123;        // 如果没有找到 那么就在当前索引前面插入新元素        createElm(          newStartVnode,          insertedVnodeQueue,          parentElm,          oldStartVnode.elm,          false,          newCh,          newStartIdx        );      &#125; else &#123;        // 有index就直接复用元素        vnodeToMove = oldCh[idxInOld];        // 同元素情况下        if (sameVnode(vnodeToMove, newStartVnode)) &#123;          patchVnode(            vnodeToMove,            newStartVnode,            insertedVnodeQueue,            newCh,            newStartIdx          );          oldCh[idxInOld] = undefined;          // 在前面插入          canMove &amp;&amp;            nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);        &#125; else &#123;          // same key but different element. treat as new element          createElm(            newStartVnode,            insertedVnodeQueue,            parentElm,            oldStartVnode.elm,            false,            newCh,            newStartIdx          );        &#125;      &#125;      newStartVnode = newCh[++newStartIdx];    &#125;  &#125;  // 如果对比完成  // 如果旧起始大于旧结束 说明新的里面的东西都是新增的 就加入  if (oldStartIdx &gt; oldEndIdx) &#123;    refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;    addVnodes(      parentElm,      refElm,      newCh,      newStartIdx,      newEndIdx,      insertedVnodeQueue    );  &#125; else if (newStartIdx &gt; newEndIdx) &#123;    // 如果新开始大于新结束，那说明旧的里面的dom是被删除 就移除调    removeVnodes(oldCh, oldStartIdx, oldEndIdx);  &#125;&#125;\n\ndiff 算法是怎么 diff？下面用一个例子来做一层模拟 更直观地展示，上方为 oldVnode，下方为 newVnode，key 为内容数字，且唯一\n\nStep1: 新头旧头，新尾旧尾，新头旧尾，新尾旧头对比后，发现并不一致，进入源码中的最后一个 else 内部，进入之后oldKeyToIdx 为 undefined，初始化 oldKeyToIdx 的值。因为 newStartVnode 有值，idxInOld &#x3D; oldKeyToIdx[newStartVnode.key]等于 1，调用 createElement 在 oldStartVnode 前面插入 newStartVnode，newStartIndex++。此时 oldStartIndex：0,oldEndIndex：2，newStartIndex：1，newEndIndex：3\n\nStep2: 新头旧头对比后发现都为 1，一致 newStartIndex,oldStartIndex 都+1，当前层不进行复用&#x2F;排列操作，保存本位。此时 oldStartIndex：1,oldEndIndex：2，newStartIndex：2，newEndIndex：3\n\nStep3: 旧尾新头对比后发现都为 3，newStartIndex+1，oldEndIndex-1，此时 oldStartIndex：1,oldEndIndex：1，newStartIndex：3，newEndIndex：3\n\nStep3: 头尾相比发现都不一致，进入 else 内部，oldKeyToIdx 数组内部没有第 4 个的值 所以在 newStartIndex 前面插入 4，newStartIdx+1，此时 newStartIndex &gt; newOldIndex,就移除旧数组的 oldStartIdx 到 oldEndIdx 的 vnode，也就是 2，最后返回 2134\n从上图源码来看，可以得出，diff 算法会依照固定的判断同层级 Vnode 的顺序进行头头，尾尾，头尾，尾头的比较不断收缩 4 个定义的下标的位置来进行 dom 的重排和复用操作\n解决第 2，3 个问题,探究下本质为什么会出现 key 绑定为 index，或者不绑定情况下删除会删除最后一项问题呢，这其实涉及到了 vnode 的渲染原理\n\n假如按照上面代码通过调用编译后的 render 函数调用 _l 方法也就是 renderList 调用 createElement 方法初始化了多个 vnode，在绑定 key 为 index 的情况下 增加 3 个删除第一个，打印 vnode 大概是这样的，\n\n123456789101112131415/*旧vnodechildren: Array(3)0: VNode &#123;tag: &quot;li&quot;, data: &#123;…&#125;, children: Array(3), text: undefined, key: 0, …&#125;1: VNode &#123;tag: &quot;li&quot;, data: &#123;…&#125;, children: Array(3), text: undefined, key: 1, …&#125;2: VNode &#123;tag: &quot;li&quot;, data: &#123;…&#125;, children: Array(3), text: undefined, key: 2, …&#125;*/*新vnodechildren: Array(2)0: VNode &#123;tag: &quot;li&quot;, data: &#123;…&#125;, children: Array(3), text: undefined, key: 0, …&#125;1: VNode &#123;tag: &quot;li&quot;, data: &#123;…&#125;, children: Array(3), text: undefined, key: 1, …&#125;*/\n\n由上可知，key 是不变的，但是实际上 dom 内容已经变了。这就会导致在头头对比之中因为双方 key 一致，从而判断为同个 vnode，会使 newStartIdx 和 oldStartIndex 一致向右进 1, 最后 newStarteIndex &gt; newEndIndex, 导致 oldStartIndex 到 oldEndIndex 之间的 vnode 被删除，所以这才会出现删除的总是最后一项的情况。没有绑定 key 时情况也是如此。具体如下图所示\n\n解决第 4 个问题，就地复用在哪里得到体现？源码中，如果新的节点在旧的节点列表上有出现的 ，那么就会存储当前 Vnode，直接插入到 dom 前面，复用旧 Vnode，不创建新的 dom。如下源码：\n1234567891011121314151617function updateChildren() &#123;  // 拿到旧代码 直接存储  vnodeToMove = oldCh[idxInOld];  if (sameVnode(vnodeToMove, newStartVnode)) &#123;    patchVnode(      vnodeToMove,      newStartVnode,      insertedVnodeQueue,      newCh,      newStartIdx    );    oldCh[idxInOld] = undefined;    // 在前面插入    canMove &amp;&amp;      nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);  &#125;&#125;\n\n\n\n\n\n\n\n\n\n\n以上就是我看源码得出的结论，有疑问的小伙伴可以在下方留言。thanks！！！\n","slug":"Vue2.6源码解析之diff算法更新过程及其相关问题","date":"2021-12-25T16:00:00.000Z","categories_index":"Vue,总结,Vue源码","tags_index":"Vue","author_index":"谢小谢"},{"id":"92857319a9a1729d512b153f0e035994","title":"总结下前段时间公司项目中的Better-scroll封装","content":"总结下自己前一段时间公司项目使用 Better-scroll 进行总体封装，集成下拉刷新,上拉加载等\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167&lt;template&gt;  &lt;div class=&quot;wrapper&quot; :ref=&quot;refUuid&quot;&gt;    &lt;div class=&quot;wrapper--content&quot; :ref=&quot;`$&#123;refUuid&#125;Content`&quot;&gt;      &lt;div class=&quot;pulldown-wrapper&quot; v-if=&quot;pulldown&quot;&gt;        &lt;div v-show=&quot;beforePullDown&quot;&gt;&lt;span&gt;下拉刷新&lt;/span&gt;&lt;/div&gt;        &lt;div v-show=&quot;!beforePullDown&quot;&gt;          &lt;div v-show=&quot;isPullingDown&quot;&gt;            &lt;van-loading size=&quot;24px&quot; type=&quot;spinner&quot;&gt;加载中...&lt;/van-loading&gt;          &lt;/div&gt;          &lt;div v-show=&quot;!isPullingDown&quot;&gt;&lt;span&gt;刷新成功&lt;/span&gt;&lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;      &lt;slot&gt;&lt;/slot&gt;      &lt;div        class=&quot;pullup-wrapper&quot;        v-if=&quot;pullup &amp;&amp; showPullup &amp;&amp; showHasMoreScreen&quot;      &gt;        &lt;div v-if=&quot;!isPullUpLoad&quot; class=&quot;before-trigger&quot;&gt;          &lt;span class=&quot;pullup-txt&quot;&gt;上拉刷新&lt;/span&gt;        &lt;/div&gt;        &lt;div v-else class=&quot;after-trigger&quot;&gt;          &lt;van-loading size=&quot;24px&quot; type=&quot;spinner&quot; v-if=&quot;hasMore&quot;            &gt;加载中...&lt;/van-loading          &gt;          &lt;span v-else&gt;没有更多了。。。。。&lt;/span&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import BScroll from &quot;better-scroll&quot;;import &#123; v4 as uuidv4 &#125; from &quot;uuid&quot;;export default &#123;  data() &#123;    return &#123;      scroll: null,      refUuid: uuidv4(),      showPullup: true, // 是否展示加载更多栏目    &#125;;  &#125;,  props: &#123;    /**     * 1 滚动的时候会派发scroll事件，会截流。     * 2 滚动的时候实时派发scroll事件，不会截流。     * 3 除了实时派发scroll事件，在swipe的情况下仍然能实时派发scroll事件     */    probeType: &#123; type: Number, default: 1 &#125;, // 点击列表是否派发click事件    click: &#123; type: Boolean, default: true &#125;, // 是否开启横向滚动    scrollX: &#123; type: Boolean, default: false &#125;, // 是否派发滚动到底部的事件，用于上拉加载    pullup: &#123; type: Boolean, default: false &#125;, // 是否派发顶部下拉的事件，用于下拉刷新    pulldown: &#123; type: Boolean, default: false &#125;, // 刷新的时延    refreshDelay: &#123; type: Number, default: 20 &#125;, // 数据源    data: &#123; type: [Array, Object], default: null &#125;, // 开始下拉    beforePullDown: &#123; type: Boolean, default: true &#125;, // 下拉中    isPullingDown: &#123; type: Boolean, default: false &#125;, // 上拉中    isPullUpLoad: &#123; type: Boolean, default: false &#125;, // 是否有更多数据    hasMore: &#123; type: Boolean, default: true &#125;, // 是否展示底部的加载更多数据    showHasMoreScreen: &#123; type: Boolean, default: true &#125;,  &#125;,  mounted() &#123;    this.$nextTick(() =&gt; &#123;      setTimeout(() =&gt; &#123;        this.initBetterScroll();        this.refreshPullRegion();        this.refreshScrollXRegion();      &#125;, 10);      setTimeout(() =&gt; &#123;        this.initcroll();      &#125;, 10);    &#125;);  &#125;,  watch: &#123;    // 监听数据的变化，延时 refreshDelay 时间后调用 refresh 方法重新计算，保证滚动效果正常    data() &#123;      setTimeout(() =&gt; &#123;        this.refresh();      &#125;, this.refreshDelay);    &#125;,  &#125;,  methods: &#123;    // 判断滚动区域是否大于呈现区域 如果大于 就不可能出现上拉刷新显示区    refreshPullRegion() &#123;      if (        this.$refs[this.refUuid].clientHeight &gt;        this.$refs[`$&#123;this.refUuid&#125;Content`].clientHeight      ) &#123;        this.showPullup = false;      &#125; else &#123;        this.showPullup = true;      &#125;      console.log(&quot;----结束&quot;, this.showPullup);    &#125;,    refreshScrollXRegion() &#123;      if (this.scrollX) &#123;        this.$refs[`$&#123;this.refUuid&#125;Content`].style.position = &quot;absolute&quot;;      &#125;    &#125;,    initBetterScroll() &#123;      // 没有就为空      if (!this.$refs[this.refUuid]) return;      const config = &#123;&#125;;      if (this.pulldown) &#123;        config.pullDownRefresh = &#123; stop: 56, threshold: 70 &#125;;      &#125;      if (this.pullup) &#123;        config.pullUpLoad = true;      &#125;      if (this.scrollX) &#123;        config.scrollX = true;      &#125;      // 开始初始化      this.scroll = new BScroll(this.$refs[this.refUuid], &#123;        click: true,        scrollY: true,        observeDOM: true,        ...config,      &#125;);      // 如果有开启下拉 就监听下拉事件      if (this.pulldown) &#123;        this.scroll.on(&quot;pullingDown&quot;, async () =&gt; &#123;          this.$emit(&quot;pulldown&quot;);        &#125;);      &#125;      // 如果有开启上拉 就监听上拉事件      if (this.pullup) &#123;        this.scroll.on(&quot;pullingUp&quot;, async () =&gt; &#123;          this.$emit(&quot;pullup&quot;);        &#125;);      &#125;    &#125;,    refresh() &#123;      if (this.pullup) &#123;        this.scroll.finishPullUp();      &#125;      this.scroll &amp;&amp; this.scroll.refresh();      this.refreshPullRegion();      this.refreshScrollXRegion();    &#125;,  &#125;,&#125;;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.wrapper &#123;  flex: 1;  overflow: hidden;  position: relative;  &amp;--content &#123;    z-index: 2;    .pulldown-wrapper &#123;      position: absolute;      width: 100%;      padding: 20px;      box-sizing: border-box;      transform: translateY(-100%) translateZ(0);      text-align: center;      color: #999;    &#125;    .pullup-wrapper &#123;      padding: 20px;      text-align: center;      color: #999;    &#125;  &#125;&#125;&lt;/style&gt;\n","slug":"总结下前段时间公司项目中的Better-scroll封装","date":"2021-12-21T16:00:00.000Z","categories_index":"vue,经验","tags_index":"better-scroll,vue","author_index":"谢小谢"},{"id":"d36c9246f4e0462addbf95d33343891c","title":"Vue.2.6源码分析之事件挂载和双向绑定原理","content":"对于用 vue 的小伙伴来说，v-model 是 vue 开发过程中使用非常频繁的一个指令，它实现了数据的双向绑定。那么现在，我们就来探究一下发生双向绑定的过程是如何实现的\n设想一下绑定过程我们都知道，传入 data 的数据会被 Object.defineProperty 转化成 getter,setter进行监听，v-model 则是需要 input 框支持。当 input 输入时，view 层的数据也会随之动态改变，那么很明显是需要通过一个事件监听方法来触发的。当数据层被触发时，响应，那事件监听事件是在啥时候就开始挂载事件的呢?\n看看源码中事件怎么监听的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// src\\\\platforms\\\\web\\\\compiler\\\\directives\\\\model.jsfunction genDefaultModel(  el: ASTElement,  value: string,  modifiers: ?ASTModifiers): ?boolean &#123;  const type = el.attrsMap.type;  const &#123; lazy, number, trim &#125; = modifiers || &#123;&#125;;  // 没有携带lazy修饰符并且input类型伟range时就需要进行compsition检测  const needCompositionGuard = !lazy &amp;&amp; type !== &quot;range&quot;;  // 1.如果v-model携带lazy修饰符，那么就自动转成change事件  // change和input事件的区别: https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/change_event  // 2.如果不是滑块类型的input 那么就默认是input事件  const event = lazy ? &quot;change&quot; : type === &quot;range&quot; ? RANGE_TOKEN : &quot;input&quot;;  // 拼装执行语句  let valueExpression = &quot;$event.target.value&quot;;  if (trim) &#123;    valueExpression = `$event.target.value.trim()`;  &#125;  if (number) &#123;    valueExpression = `_n($&#123;valueExpression&#125;)`;  &#125;  // 调用genAssignmentCode语句重组  // 如果value有值，实际上调用的是this.$set方法  // if($event.target.composing)return;$set(day, key, $event.target.value)  let code = genAssignmentCode(value, valueExpression);  if (needCompositionGuard) &#123;    // composition事件 即输入法编辑器编辑时 就直接返回空    code = `if($event.target.composing)return;$&#123;code&#125;`;  &#125;  addProp(el, &quot;value&quot;, `($&#123;value&#125;)`);  // 增加监听事件  addHandler(el, event, code, null, true);  // 如果修饰符是trim或number那么应当立即强制更新  if (trim || number) &#123;    addHandler(el, &quot;blur&quot;, &quot;$forceUpdate()&quot;);  &#125;&#125;// src\\\\compiler\\\\helpers.js 塞进对象export function addHandler(  el: ASTElement,  name: string,  value: string,  modifiers: ?ASTModifiers,  important?: boolean,  warn?: ?Function,  range?: Range,  dynamic?: boolean) &#123;  modifiers = modifiers || emptyObject;  let events;  if (modifiers.native) &#123;    delete modifiers.native;    events = el.nativeEvents || (el.nativeEvents = &#123;&#125;);  &#125; else &#123;    events = el.events || (el.events = &#123;&#125;);  &#125;  // 普通input状态下 返回了&#123; value: value.trim()&#125;  const newHandler: any = rangeSetItem(&#123; value: value.trim(), dynamic &#125;, range);  if (modifiers !== emptyObject) &#123;    newHandler.modifiers = modifiers;  &#125;  // 对象塞入当前监听事件  const handlers = events[name];  if (Array.isArray(handlers)) &#123;    important ? handlers.unshift(newHandler) : handlers.push(newHandler);  &#125; else if (handlers) &#123;    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];  &#125; else &#123;    events[name] = newHandler;  &#125;  el.plain = false;&#125;// src/platforms/web/runtime/modules/events.js 生成vnode后增加事件监听function add(  name: string,  handler: Function,  capture: boolean,  passive: boolean) &#123;  if (useMicrotaskFix) &#123;    const attachedTimestamp = currentFlushTimestamp;    const original = handler;    handler = original._wrapper = function (e) &#123;      if (        e.target === e.currentTarget ||        e.timeStamp &gt;= attachedTimestamp ||        e.timeStamp &lt;= 0 ||        e.target.ownerDocument !== document      ) &#123;        return original.apply(this, arguments);      &#125;    &#125;;  &#125;  // 增加事件监听  target.addEventListener(    name,    handler,    supportsPassive ? &#123; capture, passive &#125; : capture  );&#125;\n\n由上面结合源码可知，在 compiler 编译模板之后生成 ast 语法，生成 ast 语法后会对当前 ast 调用 generate 方法进行一次格式化生成 render 函数，在 patch 阶段调用 updateDOMListeners 挂载当前监听方法，下面是我总结出来的事件编译挂载的流程图\n\n再来看看如何数据的更新监听要想实现数据监听，实时变化。vue2.6 中的策略是这样的，通过 Observer 使用 Object.defineProperty 遍历劫持 data 对象的所有属性，为每个属性生成一个 Dep 消息订阅器，并且在后续挂载中生成一个 Watcher 观察者实例，当第一次调用 render 函数解析模板时，会扫描到模板里面绑定的每个属性，从而触发当前属性的 getter，把当前 Watcher 加入到每个对象的 Dep 的 sub 列表里面，当属性更新之后会就会调用当前属性的 Dep，调用其 sub 里面每个 watcher 的 update 函数来实现更新\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202// 实现依赖收集器// src/core/observer/dep.jslet uid = 0;function remove(list, item) &#123;  const index = list.indexOf(item);  list.splice(index, 1);&#125;class Dep &#123;  constructor() &#123;    this.id = uid++;    this.sub = [];  &#125;  // 订阅所有依赖  depend() &#123;    console.log(this);    if (Dep.target) &#123;      console.log(Dep.target);      Dep.target.addDep(this);    &#125;  &#125;  addSub(watcher) &#123;    this.sub.push(watcher);  &#125;  removeSub(watcher) &#123;    remove(this.sub, watcher);  &#125;  notify() &#123;    console.log(this.sub);    this.sub.forEach((watcher) =&gt; watcher.update());  &#125;&#125;Dep.taget = null;const targetStack = [];// 赋值Dep.target主要是为了禁止某些getter依赖项触发到// Dep.target有值时才能触发depend方法function pushTarget(watcher) &#123;  Dep.target = watcher;  targetStack.push(watcher);&#125;function popTarget() &#123;  targetStack.pop();  Dep.target = targetStack[targetStack.length - 1];&#125;// 实现// src/core/observer/index.jsfunction observe(data) &#123;  let ob;  // 如果是对象，就对其进行监听  if (isObject(data)) &#123;    ob = new Observer(data);  &#125;  return ob;&#125;class Observer &#123;  constructor(data) &#123;    // 初始化依赖收集器    const dep = new Dep();    if (Array.isArray(data)) &#123;    &#125; else &#123;      this.walk(data);    &#125;  &#125;  // 监听内部的每一个key  walk(data) &#123;    const keyList = Object.keys(data);    for (let i = 0; i &lt; keyList.length; i++) &#123;      defineReactive(data, keyList[i]);    &#125;  &#125;&#125;function defineReactive(data, key, value) &#123;  const dep = new Dep();  // 没有传value时默认初始化value  if (arguments.length === 2) &#123;    value = data[key];  &#125;  // 遍历子项  let child = observe(data[key]);  // 对内部每个key进行一次代理  Object.defineProperty(data, key, &#123;    enumerable: true, // 可枚举    configurable: false, // 不能再define    get() &#123;      // 依赖收集器和watcher互相绑定      if (Dep.target) &#123;        dep.depend();        if (child) &#123;          child.dep.depend();        &#125;      &#125;      return value;    &#125;,    set(newValue) &#123;      // 新旧值不同的情况下就直接更新当前函数      if (newValue !== value) &#123;        value = newValue;        child = observe(data[key]);        dep.notify();      &#125;    &#125;,  &#125;);&#125;class Watcher &#123;  constructor(vm, expOrFn, cb, options) &#123;    this.id = ++id;    this.vm = vm;    this.expOrFn = expOrFn;    this.cb = cb;    this.lazy = options.lazy || false;    this.dirty = options.lazy || false;    // 新旧队列    this.newDepIdList = [];    this.depIdList = [];    this.newDepList = new Set();    this.depList = new Set();    console.log(expOrFn);    this.getter =      typeof this.expOrFn === &quot;function&quot;        ? this.expOrFn        : createExpOrFn(this.vm, this.expOrFn);    console.log(this.getter);    this.value = this.lazy ? &quot;&quot; : this.get();  &#125;  addDep(dep) &#123;    // 收集最新的依赖    if (!this.newDepIdList.includes(dep.id)) &#123;      this.newDepIdList.push(dep.id);      this.newDepList.add(dep);      // 如果队列里面没有      if (!this.depIdList.includes(dep.id)) &#123;        dep.addSub(this);      &#125;    &#125;    console.log(dep);  &#125;  // 单纯获取最新的值  get() &#123;    let value;    try &#123;      pushTarget(this);      value = this.getter.call(this.vm);    &#125; catch (e) &#123;    &#125; finally &#123;      this.cleanDepQueue();      popTarget();      console.log(&quot;清除了&quot;, value, this.getter);    &#125;    return value;  &#125;  // 更新  update() &#123;    if (this.lazy) &#123;      this.dirty = true;    &#125; else &#123;      queueWatcher(this);    &#125;  &#125;  run() &#123;    const value = this.get();    if (value !== this.value) &#123;      const oldValue = this.value;      this.cb.call(this.vm, value, oldValue);      this.value = value;    &#125;  &#125;  cleanDepQueue() &#123;    // 收集了新的依赖 如果新的依赖里面没有旧的 那就从旧的依赖里面去掉    // 试想一下 页面的绑定了一个值,并且设置了一个v-if指令，在下一次渲染之后，    // v-if=\\&quot;false\\&quot;不渲染了 但是上一个的依赖却已经被追踪了,这样就    // 会追踪额外的依赖项了，所以必须要清除    for (const dep of this.depList) &#123;      if (!this.newDepList.has(dep)) &#123;        dep.removeSub(this);      &#125;    &#125;    // 新的赋值给旧的  清空新依赖列表 新旧对比    let current = this.depList;    this.depList = this.newDepList;    this.newDepList = current;    this.newDepList.clear();    current = this.depIdList;    this.depIdList = this.newDepIdList;    this.newDepIdList = current;    this.newDepIdList.length = 0;  &#125;&#125;\n\n如果看不太懂的话可以参考我自己写的这一份链接 new Vue 双向绑定示例\n流程图展示下面是我自己绘制的流程图，可以通过这张图的调用顺序更简明地了解更新逻辑\n\n额外的一些注意点当前实例并没有关注到一些性能上的优化点，一个一个地说明会导致篇幅太长，相关的性能处理在上面的 github 示例链接里面，各位小伙伴有兴趣的话可以点击一下查看，帮我点个 star。\n另外可以看看我的其他文章，有一些内容会和当前内容有辅助功能，涉及到了优化相关。\n\nVue2.6 源码解析之数据更新队列和 nextTick 方法解析\nVue2.6 源码解析之 diff 算法更新过程及其相关问题\n\n","slug":"Vue.2.6源码分析之事件挂载和双向绑定原理2021-12-06","date":"2021-12-05T16:00:00.000Z","categories_index":"Vue,总结,Vue源码","tags_index":"Vue","author_index":"谢小谢"},{"id":"a4e456e8c96d4967cd68b187c93c51dc","title":"Nuxt.js线上部署","content":"前段时间自己用 Next.js 的项目部署上线了，记录下 Next.js 的部署方式\nNext.js 项目模块建议使用自带的 dynamic 动态导入模块开始部署\n删除 node_modules 文件夹(文件过大，等在服务器重新下载比较合适)\nLinux 下使用 scp 命令传输到服务器&#x2F;window 下使用 xftp 工具直接拖\n\n\n\n\n\n\n\n\nscp -r 本地文件夹地址 服务器用户名@服务器 ip:远程目录地址\n\n远程目录下 npm install 安装依赖 修改 package.json 的 npm start 命令为 &gt; NODE_ENV&#x3D;production node server.js\nnpm run build\npm2 启动\n\n\n\n\n\n\n\n\npm2 start npm –name &quot;your_server_name&quot; – run start\n\n\n","slug":"Next.js线上部署2021-12-04","date":"2021-12-03T16:00:00.000Z","categories_index":"","tags_index":"Vue,服务端渲染","author_index":"谢小谢"},{"id":"4d925ea8030231a2d81ae35ccafce2c7","title":"Vue2.6源码解析之数据更新队列和nextTick方法解析","content":"用了这么久的 Vue，我们都可以从官网上面知道，Vue 在更新 DOM 时是异步执行的,Vue 将开启一个队列，缓冲在同一事件循环中发生的所有数据变更,如果同一个 watcher 被多次触发，只会被推入到队列中一次，注: 首先要了解下 js 的事件循环和异步任务队列问题\n那么内部究竟是如何实现的呢，我们对源代码进行细纠，下面会省略一些不相关的代码。\n提供第一个 template 范例如果看了我的事件循环的文章，那么就可以知道任务队列中的异步任务分 task 任务和 microTask 微任务，每一次执行 task 的时候都会执行清空该 task 下的同级 microtask，理解这个原理对源码理解有巨大作用\n123456789101112131415161718192021222324252627282930313233343536373839404142&lt;div id=&quot;app&quot; @click=&quot;setData&quot;&gt;  &lt;span&gt;&#123;&#123; les &#125;&#125;/ &#123;&#123;time&#125;&#125;&lt;/span&gt;  &lt;uptime-day :day=&quot;day&quot; :les=&quot;les&quot; :time=&quot;time&quot; /&gt;&lt;/div&gt;&lt;script&gt;  const uptimeDay = &#123;    props: [&quot;time&quot;, &quot;les&quot;],    data() &#123;      return &#123;        isTrue: true,      &#125;;    &#125;,    methods: &#123;      handleClick() &#123;        this.isTrue = false;        this.$nextTick(() =&gt; &#123;          console.log(this.uptimeDay.innerText);        &#125;);      &#125;,    &#125;,    template: `&lt;div @click=&quot;handleClick&quot; ref=&quot;uptimeDay&quot;&gt;&#123;&#123; les &#125;&#125; &#123;&#123; time &#125;&#125;&lt;/div&gt;`,  &#125;;  var app = new Vue(&#123;    el: &quot;#app&quot;,    components: &#123;      uptimeDay,    &#125;,    data() &#123;      return &#123;        les: &quot;谢小谢&quot;,        time: &quot;now&quot;,      &#125;;    &#125;,    methods: &#123;      setData() &#123;        this.les = &quot;谢谢谢&quot;;        this.time = &quot;before&quot;;      &#125;,    &#125;,  &#125;);&lt;/script&gt;\n\n这里进行一步点击操作 调用 setData 函数\n初始渲染逻辑粗略解读\n\n\n\n\n\n\n\n\n看过源码的大概都知道，new Vue 之后的最后一步是调用 mountComponent 方法生成 Watcher 订阅者，watcher 传入了一个 updateComponent 函数（内部包含\\_update,render 方法）作为 getter,初始化时 Watcher 会调用其 getter 方法，进入内部逻辑调用 render 生成 vnode，调用\\_update 方法对 vnode 进行 patch 操作,具体请看下图。\n\n当前模板在\\_createElement 时，遇到子组件，判断是不是原生标签之后，会调用 Vue.extend 方法重头调用一次 Vue.prorotype.init 方法，所以当前会生成 2 个 Watcher。\n着重看一下 queueWatcher 执行过程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// src/core/observer/scheduler.js// 最大更新数量export const MAX_UPDATE_COUNT = 100const queue: Array&lt;Watcher&gt; = []const activatedChildren: Array&lt;Component&gt; = []let has: &#123; [key: number]: ?true &#125; = &#123;&#125;let circular: &#123; [key: number]: number &#125; = &#123;&#125;let waiting = falselet flushing = falselet index = 0// 重置队列和刷新状态function resetSchedulerState() &#123;  index = queue.length = activatedChildren.length = 0  has = &#123;&#125;  waiting = flushing = false&#125;export let currentFlushTimestamp = 0let getNow: () =&gt; number = Date.nowfunction flushSchedulerQueue() &#123;  // 设置当前的时间戳  currentFlushTimestamp = getNow()  flushing = true  let watcher, id  // 所有watcher根据id升序排列  // 疑问: 点解要排序？  // 回答: 1. 组件是从父级更新到子级，组件的渲染顺序是优于父级的，如果某个组件在父组件的观察程序运行期间被销毁，则可以跳过  queue.sort((a, b) =&gt; a.id - b.id)  // queue长度随时变化  for (index = 0; index &lt; queue.length; index++) &#123;    watcher = queue[index]    if (watcher.before) &#123;      watcher.before()    &#125;    id = watcher.id    has[id] = null    watcher.run()  &#125;  // 保留上次缓存过和更新后的状态实例 为下次触发生命周期做准备  const activatedQueue = activatedChildren.slice()  const updatedQueue = queue.slice()  // 清空状态  resetSchedulerState()  // 设置当前组件更activated状态  callActivatedHooks(activatedQueue)  // 设置当前组件为已更新状态  callUpdatedHooks(updatedQueue)&#125;// 触发生命周期function callUpdatedHooks(queue) &#123;  let i = queue.length  while (i--) &#123;    const watcher = queue[i]    const vm = watcher.vm    if (vm._watcher === watcher &amp;&amp; vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;      callHook(vm, &#x27;updated&#x27;)    &#125;  &#125;&#125;export function queueActivatedComponent(vm: Component) &#123;router-view)  vm._inactive = false  activatedChildren.push(vm)&#125;function callActivatedHooks(queue) &#123;  for (let i = 0; i &lt; queue.length; i++) &#123;    queue[i]._inactive = true    activateChildComponent(queue[i], true /* true */)  &#125;&#125;// 推watcher入栈export function queueWatcher(watcher: Watcher) &#123;  const id = watcher.id  if (has[id] == null) &#123;    has[id] = true    // 当前队列没有冲刷的时候    if (!flushing) &#123;      // 把当前watcher加入队列      queue.push(watcher)    &#125; else &#123;      // 已冲刷的和已经通过的就删除掉      let i = queue.length - 1      while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;        i--      &#125;      queue.splice(i + 1, 0, watcher)    &#125;    // 不是在等待中    if (!waiting) &#123;      nextTick(flushSchedulerQueue)    &#125;  &#125;&#125;\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// src/core/util/next-tick.jsexport let isUsingMicroTask = false;const callbacks = [];let pending = false;function flushCallbacks() &#123;  pending = false;  const copies = callbacks.slice(0);  callbacks.length = 0;  for (let i = 0; i &lt; copies.length; i++) &#123;    copies[i]();  &#125;&#125;// timeFunc根据环境兼容处理使用任务或者微任务let timerFunc;if (typeof Promise !== &quot;undefined&quot; &amp;&amp; isNative(Promise)) &#123;  const p = Promise.resolve();  timerFunc = () =&gt; &#123;    p.then(flushCallbacks);    if (isIOS) setTimeout(noop);  &#125;;  isUsingMicroTask = true;&#125; else if (  !isIE &amp;&amp;  typeof MutationObserver !== &quot;undefined&quot; &amp;&amp;  (isNative(MutationObserver) ||    MutationObserver.toString() === &quot;[object MutationObserverConstructor]&quot;)) &#123;  let counter = 1;  const observer = new MutationObserver(flushCallbacks);  const textNode = document.createTextNode(String(counter));  observer.observe(textNode, &#123;    characterData: true,  &#125;);  timerFunc = () =&gt; &#123;    counter = (counter + 1) % 2;    textNode.data = String(counter);  &#125;;  isUsingMicroTask = true;&#125; else if (typeof setImmediate !== &quot;undefined&quot; &amp;&amp; isNative(setImmediate)) &#123;  timerFunc = () =&gt; &#123;    setImmediate(flushCallbacks);  &#125;;&#125; else &#123;  // Fallback to setTimeout.  timerFunc = () =&gt; &#123;    setTimeout(flushCallbacks, 0);  &#125;;&#125;// 主处理函数export function nextTick(cb?: Function, ctx?: Object) &#123;  let _resolve;  // 入栈  callbacks.push(() =&gt; &#123;    if (cb) &#123;      try &#123;        cb.call(ctx);      &#125; catch (e) &#123;        handleError(e, ctx, &quot;nextTick&quot;);      &#125;    &#125; else if (_resolve) &#123;      _resolve(ctx);    &#125;  &#125;);  // 非等待情况下  if (!pending) &#123;    pending = true;    timerFunc();  &#125;&#125;\n\ntemplate 范例解读\n根据入口遍历，根组件和子组件会生成两个 watcher 实例，从父到子我们成为 watcher1， watcher2\n由上面的 template 可知，根组件#app 和子组件 uptimeDay 都绑定了事件，点击 uptimeDay 组件时，子组件 handleClick 方法已经进入整体 task 队列，内部 isTrue 为 true 时 setter 触发，进入 queueWatcher(watcher2),has[id]为 false,flushing 为 false 进入推入 queue 队列，调用 nextTick(flushSchedulerQueue: 简称该方法为 Fn1) ，nextTick 入栈后 callBack 推入 f1，默认 pending 为 false，调用 timeFunc，此时该函数进入 handleClick 这个 task 下的微任务队列里面，pending 变 true。\n随后，下方又调用了 this.$nextTick(() &#x3D;&gt; { console.log(this.$refs.ss.innerText); 简称该方法为 Fn2 }), Fn2 进入 nextTick 之后发现 pending &#x3D; true，所以被合并进入 callBacks 更新，pending &#x3D; false 子组件 patch 更新完成 queueWatcher。 初始化 重点: 此时，props 传进来的值并没有更新影响到 dom，打印出来的对象是有滞后性的，必须打印普通类型的值才能正确显示\n接着，事件冒泡到父级，setData 触发进入另外一个 task 队列，接着更改了 les,time 的值。触发 les 的 setter 更新进入 queueWatcher(watcher1)。首先 has[id]为 null, flushing 为 false, watcher1 被推入 queue 队列调用 nextTick，nextTick 内部 pending 为 false，执行 timeFunc，推入微任务队列挂起。随后 time 的 setter 被触发，后进入 queueWatcher，发现 has[id]为 true，waiting 为 true, 不推入队列。重点: 此时，这里就是上文说的 watcher 被多次触发，只推入队列一次，接着 timeFunc 的微任务开始调用，进入 flushSchedulerQueue 完成更新\n\n结论\n同 watcher 内更新只更新一次，因为多个 data 改变时，第一次的 reRender 就可以拿到当前实例上的最新值了，无需耗费更多计算资源。\n如果外部组件修改，子组件没有绑定当前修改的属性，并且没有应用于 dom，那么也是不会更新到子组件的(这个得看一下 Observe 数据劫持和 patch 的过程才能了解)\nscheduler.js 中有一段代码是很值得玩味的\n\n123456789101112// src/core/observer/scheduler.js// queue长度随时变化for (index = 0; index &lt; queue.length; index++) &#123;  watcher = queue[index];  if (watcher.before) &#123;    watcher.before();  &#125;  id = watcher.id;  has[id] = null;  watcher.run();&#125;\n\n这里算是对上面第 4 步的补充，当根组件的实例更新后，子组件也会更新重新进入 queueWatcher，watcher2 会被推入 queue 队列，此时循环体内的 queue 长度增加, 会一层一层往下调用子组件的 watcher 的 run 方法不断地重新 render 来进行 patch 操作，直到没有子组件为止(为什么？因为 vnode 为组件类型时没有 children，无法 patch，必须得重新 render 解析组件)\n","slug":"Vue2.6源码解析之数据更新队列和nextTick方法解析2021-11-24","date":"2021-11-23T16:00:00.000Z","categories_index":"Vue,总结,Vue源码","tags_index":"Vue","author_index":"谢小谢"},{"id":"b2c8fccb8cb0e13a9e85ff1f7f24091a","title":"uni-app实现京东canvas拍照识图功能","content":"\n\n\n\n\n\n\n\n\n最近公司出了一个新的功能模块(如下图)，大提上可以描述为实现拍照完上传图片，拖动四方框拍照完成上传功能，大体样子如下图。但是我找遍了 dcloud 插件市场，找到的插件都是移动背景图片来实现裁剪的，跟京东的功能是相反的，没办法只能自己来实现这么一个插件。\n\n第一步首先就需要实现一个四方框的功能了。从上图可知，四方框有一下几个特点\n\n四个角粘连外框，随着框的大小和移动范围紧缚移动\n四方框可随意四个方向拖动\n方框外区域阴影不影响方框内\n\n那么我们根据这个特性来实现下这个功能，对于 css 规范的话使用 bem 规范\n123&lt;div class=&quot;clip__content&quot;&gt;  &lt;div v-for=&quot;(item, index) in 4&quot; :key=&quot;index&quot; class=&quot;clip__edge&quot;&gt;&lt;/div&gt;&lt;/div&gt;\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071$edge-border-width: 6rpx;.clip &#123;  &amp;__content &#123;    position: fixed;    width: 400rpx;    height: 400rpx;    left: 0;    top: 0;    border: 1px solid red;    z-index: 4;    overflow: hidden;    box-shadow: rgba(0, 0, 0, 0.5) 0 0 0 200vh;  &#125;  &amp;__edge &#123;    position: absolute;    width: 34rpx;    height: 34rpx;    border: 10rpx solid red;    pointer-events: auto;    z-index: 2;    &amp;::before &#123;      content: &quot;&quot;;      position: absolute;      z-index: 2;      width: 40rpx;      height: 40rpx;      background-color: transparent;    &#125;    &amp;:nth-child(1) &#123;      left: $edge-border-width;      top: $edge-border-width;      border-bottom-width: 0 !important;      border-right-width: 0 !important;      &amp;:before &#123;        top: -50%;        left: -50%;      &#125;    &#125;    &amp;:nth-child(2) &#123;      right: $edge-border-width;      top: $edge-border-width;      border-bottom-width: 0 !important;      border-left-width: 0 !important;      &amp;:before &#123;        top: -50%;        left: 50%;      &#125;    &#125;    &amp;:nth-child(3) &#123;      left: $edge-border-width;      bottom: $edge-border-width;      border-top-width: 0 !important;      border-right-width: 0 !important;      &amp;:before &#123;        bottom: -50%;        left: -50%;      &#125;    &#125;    &amp;:nth-child(4) &#123;      right: $edge-border-width;      bottom: $edge-border-width;      border-top-width: 0 !important;      border-left-width: 0 !important;      &amp;:before &#123;        bottom: -50%;        left: 50%;      &#125;    &#125;  &#125;\n\n根据上面的 html 和 css 出来的样式大概如下图 外部的阴影效果我们用： box-shadow: rgba(0, 0, 0, 0.5) 0 0 0 200vh 来达成\n\n第二步第二步的话就要实现移动功能了，这里是一个比较考验耐心的地方，因为涉及到多个方向的变化，需要不断地进行调试，在此之前需要先分析下四个角变化的特性，下面先看 4 个角的移动特性(以 H5 思维)\n\n第一个角的移动会改变方框的 left，top，width，right4 个值\n第二个角的移动会改变方框的 top，with，height3 个值\n第三个角的移动会改变方框的 left, width，height3 个值\n第四个角的移动会改变方框的 width，height2 个值\n四个角的移动都不能小于 4 个角的宽高，四个角的移动都不能超过屏幕，相应的逻辑需要做一下限制\n\n\n首先需要获取下屏幕宽度，区域高度(因为头部可能会有导航栏目占位，所以不拿屏幕高度)，四方框初始宽高,\n123456789101112131415161718192021uni.getSystemInfo(&#123;  success: (res) =&gt; &#123;    console.log(res);    this.systemInfo = res;  &#125;,&#125;);uni  .createSelectorQuery()  .select(&quot;.clip__content&quot;)  .fields(&#123; size: true &#125;, (data) =&gt; &#123;    this.width = data.width;    this.height = data.height;  &#125;)  .exec();uni  .createSelectorQuery()  .select(&quot;.clip&quot;)  .fields(&#123; size: true &#125;, (data) =&gt; &#123;    this.screenHeight = data.height;  &#125;)  .exec();\n\n后续的话就可以进行四个角拖拽了，这里用到了 touchStart 和 touchMove,动态地为方框绑定样式\n1234567&lt;div  v-for=&quot;(item, index) in 4&quot;  class=&quot;clip__edge&quot;  @touchstart.stop.prevent=&quot;edgeTouchStart&quot;  @touchmove.stop.prevent=&quot;e =&gt; edgeTouchMove(e, index)&quot;  @touchend.stop.prevent=&quot;edgeTouchEnd&quot;&gt;&lt;/div&gt;\n\n接下来开始写逻辑\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687edgeTouchStart(e) &#123;  // 记录坐标xy初始位置  this.clientX = e.changedTouches[0].clientX;  this.clientY = e.changedTouches[0].clientY;&#125;,edgeTouchMove(e, index) &#123;  const currX = e.changedTouches[0].clientX;  const currY = e.changedTouches[0].clientY;  // 记录坐标差  const moveX = currX - this.clientX;  const moveY = currY - this.clientY;  // 更新坐标位置  this.clientX = currX;  this.clientY = currY;  const &#123; width, height, left, top, screenHeight &#125; = this;  const &#123; screenWidth &#125; = this.systemInfo;  // 初始化最大宽高  let maxWidth = 0,    maxHeight = 0,    maxTop = top + moveY &lt; 0 ? 0 : top + moveY,    maxLeft = left + moveX &lt; 0 ? 0 : left + moveX;  // 四个角的宽高限制  if (index % 2 === 0) &#123;    maxWidth = width - moveX &gt; screenWidth ? screenWidth : width - moveX;  &#125; else &#123;    maxWidth = width + moveX &gt; screenWidth ? screenWidth : width + moveX;  &#125;  if (index &lt; 2) &#123;    maxHeight =      height - moveY &gt; screenHeight ? screenHeight : height - moveY;  &#125; else &#123;    maxHeight =      height + moveY &gt; screenHeight ? screenHeight : height + moveY;  &#125;  // 四个角的规则计算逻辑 四边方框暂定40 更详细的要用.createSelectorQuery()去拿  if (index === 0) &#123;    if (width - moveX &lt;= 40 || height - moveY &lt;= 40) return;    console.log(maxLeft);    this.clipStyle = &#123;      width: maxWidth,      height: maxHeight,      left: maxLeft,      top: maxTop,    &#125;;    this.width = maxWidth;    this.height = maxHeight;    this.top = maxTop;    this.left = maxLeft;    // 右上角  &#125; else if (index === 1) &#123;    if (width + moveX &lt;= 40 || height - moveY &lt;= 40) return;    this.clipStyle = &#123;      width: maxWidth,      height: maxHeight,      left,      top: maxTop,    &#125;;    this.width = maxWidth;    this.height = maxHeight;    this.top = maxTop;  &#125; else if (index === 2) &#123;    if (width - moveX &lt;= 40 || height + moveY &lt;= 40) return;    this.clipStyle = &#123;      width: maxWidth,      height: maxHeight,      left: maxLeft,      top,    &#125;;    this.width = maxWidth;    this.height = maxHeight;    this.left = maxLeft;  &#125; else if (index === 3) &#123;    if (width + moveX &lt;= 40 || height + moveY &lt;= 40) return;    this.clipStyle = &#123;      width: maxWidth,      height: maxHeight,      left,      top,    &#125;;    this.width = maxWidth;    this.height = maxHeight;  &#125;&#125;\n\n效果如下图\n\n第三步四个角拖拽逻辑完善之后，下一步目标就是做四方框的拖拽，这边需要对四方框的拖拽做一次限制\n12345678&lt;div  class=&quot;clip__content&quot;  :style=&quot;style&quot;  @touchstart.stop.prevent=&quot;clipTouchStart&quot;  @touchmove.stop.prevent=&quot;clipTouchMove&quot;&gt;  ...&lt;/div&gt;\n\n12345678910111213141516171819202122232425262728293031323334clipTouchStart(e) &#123;  this.touchX = e.changedTouches[0].pageX;  this.touchY = e.changedTouches[0].pageY;&#125;,clipTouchMove(e) &#123;  const &#123; screenWidth &#125; = this.systemInfo;  const currX = e.changedTouches[0].pageX;  const currY = e.changedTouches[0].pageY;  const moveX = currX - this.touchX;  const moveY = currY - this.touchY;  this.touchX = currX;  this.touchY = currY;  // 边框限制逻辑  if (this.left + moveX &lt; 0) &#123;    this.left = 0;  &#125; else if (this.left + moveX &gt; screenWidth - this.width) &#123;    this.left = screenWidth - this.width;  &#125; else &#123;    this.left = this.left + moveX;  &#125;  if (this.top + moveY &lt; 0) &#123;    this.top = 0;  &#125; else if (this.top + moveY &gt; this.screenHeight - this.height) &#123;    this.top = this.screenHeight - this.height;  &#125; else &#123;    this.top = this.top + moveY;  &#125;  this.clipStyle = &#123;    ...this.clipStyle,    left: this.left,    top: this.top,  &#125;;&#125;,\n\n效果如下图：\n\n第四步就是做我们的截图了，这里用到了 canvas1234&lt;div class=&quot;clip__content&quot;&gt;  ...  &lt;canvas class=&quot;clip-canvas&quot; canvas-id=&quot;clip-canvas&quot;&gt;&lt;/canvas&gt;&lt;/div&gt;\n\n\n\n\n\n\n\n\n\n\n逻辑的话目前这个例子是使用了网络的 url 图片 所以要进行 download，如果是不用网络图片，那么这一句可以删除换成其他的获取图片 api\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364initCanvas() &#123;  uni.showLoading(&#123;    title: &quot;加载中...&quot;,  &#125;);  uni    .createSelectorQuery()    .select(&quot;.clip__content&quot;)    .fields(      &#123;        size: true,        scrollOffset: true,        rect: true,        context: true,        computedStyle: [&quot;transform&quot;, &quot;translateX&quot;],        scrollOffset: true,      &#125;,      (data) =&gt; &#123;        uni.downloadFile(&#123;          url: this.imageUrl,          success: (res) =&gt; &#123;            this.canvasInstance = uni.createCanvasContext(              &quot;clip-canvas&quot;,              this            );            this.canvasInstance.drawImage(              res.tempFilePath,              -data.left,              -data.top,              this.systemInfo.screenWidth,              this.screenHeight,              0,              0            );            this.canvasInstance.draw(              false,              (() =&gt; &#123;                setTimeout(() =&gt; &#123;                  uni.canvasToTempFilePath(                    &#123;                      x: 0,                      y: 0,                      width: data.width,                      height: data.height,                      dWidth: data.width,                      dHeight: data.height,                      fileType: &quot;jpg&quot;,                      canvasId: &quot;clip-canvas&quot;,                      success: (data) =&gt; &#123;                        uni.hideLoading();                        this.url = data.tempFilePath;                        // this.canvasInstance.save();                      &#125;,                    &#125;,                    this                  );                &#125;, 500);              &#125;)()            );          &#125;,        &#125;);      &#125;    )    .exec();&#125;,\n\n效果如图所示：\n\n最后，我们的插件就正式完成了\n具体代码可以看这个仓库链接，有什么问题可以在下方留言\n","slug":"uni-app实现京东canvas拍照识图功能","date":"2021-11-13T16:00:00.000Z","categories_index":"uni-app","tags_index":"uni-app,canvas,微信小程序","author_index":"谢小谢"},{"id":"c583867df2db339c8477f09807897308","title":"懂表帝项目阶段性总结","content":"uni-app 懂表帝小程序 v2.1.0 已经发布上线，现在针对里面遇到的一些小问题做一下阶段性的复盘\n安卓 P30 下点击 input 框聚焦后点击其他 dom，input 框的 blur 周期没有触发导致底部栏悬空不下坠，大概样子如下图\n12345678910111213141516171819202122232425262728// sendMessage.vue&lt;wb-safe-footer  :customStyle=&quot;&#123; bottom: bottom + &#x27;px&#x27;, zIndex: 999 &#125;&quot;&gt;  &lt;div class=&quot;send-message&quot;&gt;    &lt;input      ...      ref=&quot;input&quot;      v-model=&quot;message&quot;      confirm-type=&quot;send&quot;      @focus=&quot;handleFoucs&quot;      @blur=&quot;handleBlur&quot;    /&gt;  &lt;/div&gt;&lt;/wb-safe-footer&gt;&lt;script&gt;  // 聚焦  handleFocus(&#123; mp &#125;) &#123;    this.bottom = mp.detail.height    this.$emit(&#x27;focus&#x27;)  &#125;,  // 失焦  handleBlur() &#123;    this.$emit(&#x27;blur&#x27;)    this.bottom = 0  &#125;&lt;/script&gt;\n\n大概代码如上,通过 blur 改变 bottom 值，但是 blur 不触发 只好在外部函数内直接调用 handleBlur 方法\n123456789101112131415161718// shortVideo.vue&lt;comments  ...  @close=&quot;closeCommentsPopup&quot;/&gt;&lt;send-message  ...  ref=&quot;sendMessage&quot;/&gt;&lt;script&gt;// 关闭弹框closeCommentsPopup() &#123;  // 解决华为P30下键盘向下没触发input框的blur钩子问题  this.$refs.sendMessage.handleBlur()&#125;&lt;/script&gt;\n\n华为 P30 和小米 8 下 chooseImage 导致空栏目问题\n解决办法：用 showModel 模拟出两个选择方式的状态\n","slug":"懂表帝项目阶段性总结","date":"2021-09-02T16:00:00.000Z","categories_index":"uni-app","tags_index":"uni-app,懂表帝","author_index":"谢小谢"},{"id":"d02145c722134b6141381c5add87923b","title":"服务器之正向代理和反向代理","content":"最近公司商家入驻准备上线，和运维在服务器代理这边折腾了不少时间，现在重新归纳一下正向代理和反向代理的相关概念和区别\n正向代理简述：正向代理服务器作接受来自客户端的请求，请求源服务器，把原服务器返回的内容响应给客户端\n注意：(此时源服务器并不知道客户端是谁)\n\n正向代理的应用&#x2F;使用原因：\n\n网址被墙，就可以在外网架设一个服务器作为中间服务器进行代理转发\n隐藏自身的浏览行为\n\n反向代理简述: 同正向代理一样，但是客户端并不知道实际访问的源服务器是谁，因为源服务器实际上可能会有多个，所以实际上像访问谷歌这种网页，都是要经过一层反向代理的服务器\n\n反向代理的应用&#x2F;使用原因：\n\n基于安全原因，不想直接暴露源服务器地址，就可以使用一个反向代理服务器，连接内外网，将反向代理服务器层作为类防火墙功能，进行安全校验。\n服务器负载均衡，访问一个资源时，根据源服务器的具体工作情况，分发到合适的服务器之中)\n\n反向代理和正向代理的区别\n\n\n\n\n\n\n\n\n正向代理服务器只对客户端负责，即隐藏用户\n\n\n\n\n\n\n\n\n\n反向代理服务器只对自己所代理的服务器负责，即隐藏源服务器\nVue 框架的开发时反向代理服务器路径设置及其区别12345678910// 请求地址 /api/blog/tags&#x27;/api&#x27; : &#123;target: &#x27;http://127.0.0.1:7001&#x27;,  pathRewrite: &#123;    &#x27;^/api&#x27;: &#x27;/blog&#x27; // 重写了url 相当于请求 http://127.0.0.1:7001/blog/blog/tags    &#x27;^/api&#x27;: &#x27;&#x27; // 重写了url 相当于请求 http://127.0.0.1:7001/blog/tags    &#x27;&#x27;: &#x27;&#x27; // 重写了url 相当于请求 http://127.0.0.1:7001/api/blog/tags  &#125;&#125;\n","slug":"服务器之正向代理和反向代理","date":"2021-07-27T16:00:00.000Z","categories_index":"总结","tags_index":"http","author_index":"谢小谢"},{"id":"e9c62f00849307d6c77e106ff0b62f1c","title":"Http权威指南阅读总结","content":"HTTP 基础分层架构\n应用层: HTTP，DNS，FTP\n传输层: TCP，UDP\n网络层: IP\n数据链路: 控制操作系统、硬件的设备驱 动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等 物理可见部分（还包括连接器等一切传输媒介）。\n\n请求过程每个层的作用HTTP 生成请求报文，TCP 按顺序将报文切割生成多个顺序序号的报文段，把报文段可靠地传输给对方，IP 主要搜索对方的地址，一边中转一遍传送(因为每个地址在同一局域网的情况是很少的，所以可能需要多次中转，使用 ARP 协议解析地址)\nHTTP&#x2F;1.1 特点\nconnection: keep-alive 持久链接(减少 tcp 建立和资源获取的时间，注: http&#x2F;1.0 并未标准化)\n管线化(不用等待响应就能发送下一次请求)\n\nHTTP&#x2F;1.1 的客户身份认证方式\nBASIC 认证（基本认证）\nDIGEST 认证（摘要认证）\nSSL 客户端认证\nFormBase 认证（基于表单认证）\n\nHTTP&#x2F;2.0 新增\n多路复用流（通过单一的 TCP 连接，可以无限制处理多个 HTTP 请求。所有请求 的处理都在一条 TCP 连接上完成，因此 TCP 的处理效率得到提高）\n赋予请求优先级 （SPDY 不仅可以无限制地并发处理请求，还可以给请求逐个分配优先 级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响 应变慢的问题。）\n压缩 HTTP 首部\n服务端推送\n\nHTTP 报文详解\n内容压缩 gzip（GNU zip），compress（UNIX 系统的标准压缩），deflateidentity（不进行编码）（zlib）\n\nHTTP 状态码\n1XX Informational（信息性状态码） 接收的请求正在处理\n2XX Success（成功状态码） 请求正常处理完毕\n3XX Redirection（重定向状态码） 需要进行附加操作以完成请求\n4XX Client Error（客户端错误状态码） 服务器无法处理请求\n5XX Server Error（服务器错误状态码） 服务器处理请求出错\n\n其中 301(永久重定向)，302(临时重定向) 301 会导致 url 劫持，搜索引擎搜索到的自己发布的内容是在别人的网站上\n400(传参错误)，401(鉴权失效，未登录), 403(无权限)，404(没有找到该 URL)\n与 HTTP 协作的 web 服务器（代理、网关、隧 道）\n网关和代理基本功能差不多，但是当 HTTP 请求的对象不支持 HTTP 协议时，利用网关可以由 HTTP 请求转化为其他协议通信，利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信 线路上加密以确保连接的安全。比如，网关可以连接数据库，使用 SQL 语句查询数据。另外，在 Web 购物网站上进行信用卡结算时， 网关可以和信用卡结算系统联动。\n隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL 等 加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的 通信。\n\nHTTP 协议缺点\n通信使用明文（不加密），内容可能会被窃听(TSL,SSL 加密解决)\n不验证通信方的身份，因此有可能遭遇伪装(SSL 加密提供证书)\n无法验证报文的完整性,内容有可能被篡改，也就是 DOS 中间人攻击(MD5 和 SHA-1 等散列值校验)\n\nHTTP 加密\n采用对称加密和非对称加密(公开密钥加密方式获取公钥，保证安全性，用共享密钥进行解密，提升速度， 共享密闭比公开密钥的速度快)\nHTTPS 采用混合加密机制 HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密 机制。若密钥能够实现安全交换，那么有可能会考虑仅使用公开 密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处 理速度要慢。 所以应充分利用两者各自的优势，将多种方法组合起来用于通 信。在交换密钥环节使用公开密钥加密方式，之后的建立通信交 换报文阶段则使用共享密钥加密方式。\n\n如何判断公开密钥的正确性？ 使用 CA 证书\n","slug":"Http权威指南阅读总结","date":"2021-07-04T16:00:00.000Z","categories_index":"http","tags_index":"http","author_index":"谢小谢"},{"id":"fb926e417168eb419b385ba9a5f127a1","title":"懂表帝微信小程序授权流程总览","content":"之前微信小程序官方使用了新的 wx.getUserProfile 替换了旧的 wx.getUserInfo，因为做了很多小程序的登录授权，一段时间不接触之后又会忘记。在此先记录下来新版本的授权流程\n明确某些值的概念\ncode：用户登录标识（有效期五分钟），由 wx.Login 返回\nencryptedData：包括敏感数据在内的完整用户信息的加密数据，wx.getUserProfile 或  等 api 返回\niv：加密算法的初始向量，wx.getUserProfile 或  等 api 返回\ncloudID：开通云开发的小程序才会返回，可通过云调用直接获取开放数据，wx.getUserProfile 或  等 api 返回\nuserInfo：授权时的用户数据，wx.getUserProfile 返回\nappId：小程序的唯一标识, 注册小程序时自动生成\nunionId：用户的唯一标识, 调用后端的登录接口后返回\nopenId：用户在微信开放平台帐号下的唯一标识, 调用后端的登录接口后返回\n\n懂表帝微信登录结构图整理\n下面这张是微信官方的授权流程图，参考使用\n","slug":"懂表帝微信小程序授权流程总览","date":"2021-07-02T16:00:00.000Z","categories_index":"业务流程","tags_index":"小程序","author_index":"谢小谢"},{"id":"ed256b7d0dc1c9858a4d40687aeaf04d","title":"Dcloud的Canvas插件二次改写为Vue模板","content":"由于公司用的海报图插件都是使用的canvas_drawer插件来绘制海报图，由于是 18 年的插件，且只支持微信小程序原生语法。如果有其他客户端小程序的要求下是无法兼容的，对此我将他改造成 vue 组件形式来适配 uni-app 的多客户端需求\n改造要点\n部分 setData 语法存在异步情况，可能会导致逻辑问题\n旧文件里面使用的 promise.then 语法太过于冗杂，更换成 async await 语法兼容\n旧的 triggerEvent 更换成 emit\n字节小程序同时进行 2 次渲染会导致渲染重叠，传入的 id 实例不能重复\n\n下面看主要改造后的代码\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337&lt;template&gt;  &lt;view&gt;    &lt;canvas      :canvas-id=&quot;name&quot;      :style=&quot;&#123; width: width + &#x27;px&#x27;, height: height + &#x27;px&#x27; &#125;&quot;      class=&quot;board&quot;      v-if=&quot;showCanvas&quot;    &gt;&lt;/canvas&gt;  &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  props: &#123;    painting: &#123;      type: Object,    &#125;,    name: &#123;      type: String,    &#125;,  &#125;,  data() &#123;    return &#123;      showCanvas: false,      width: 100,      height: 100,      tempFileList: [],      isPainting: false,      ctx: null,      cache: Array(),    &#125;;  &#125;,  watch: &#123;    painting(newVal, oldVal) &#123;      if (!this.isPainting) &#123;        if (JSON.stringify(newVal) !== JSON.stringify(oldVal)) &#123;          if (newVal &amp;&amp; newVal.width &amp;&amp; newVal.height) &#123;            this.showCanvas = true;            this.isPainting = true;            this.readyPigment();          &#125;        &#125; else &#123;          if (newVal &amp;&amp; newVal.mode !== &quot;same&quot;) &#123;            // this.triggerEvent(&#x27;getImage&#x27;, &#123;errMsg: &#x27;canvasdrawer:samme params&#x27;&#125;)            this.$emit(&quot;getImage&quot;, &#123; errMsg: &quot;canvasdrawer:samme params&quot; &#125;);          &#125;        &#125;      &#125;    &#125;,  &#125;,  onReady() &#123;    uni.removeStorageSync(&quot;canvasdrawer_pic_cache&quot;);    this.ctx = uni.createCanvasContext(this.name, this);  &#125;,  methods: &#123;    readyPigment() &#123;      const width = this.painting.width;      const height = this.painting.height;      const views = this.painting.views;      this.width = width;      this.height = height;      const inter = setInterval(() =&gt; &#123;        if (this.ctx) &#123;          clearInterval(inter);          // this.ctx.clearActions()          this.ctx.save();          this.getImagesInfo(views);        &#125;      &#125;, 100);    &#125;,    async getImagesInfo(views) &#123;      const imageList = [];      for (let i = 0; i &lt; views.length; i++) &#123;        if (views[i].type === &quot;image&quot;) &#123;          imageList.push(await this.getImageInfo(views[i].url));        &#125;      &#125;      this.tempFileList = imageList;      this.startPainting();    &#125;,    startPainting() &#123;      const tempFileList = this.tempFileList;      const views = this.painting.views;      // const &#123; tempFileList, painting: &#123; views &#125; &#125; = this.$data      for (let i = 0, imageIndex = 0; i &lt; views.length; i++) &#123;        if (views[i].type === &quot;image&quot;) &#123;          this.drawImage(&#123;            ...views[i],            url: tempFileList[imageIndex],          &#125;);          imageIndex++;        &#125; else if (views[i].type === &quot;text&quot;) &#123;          if (!this.ctx.measureText) &#123;            uni.showModal(&#123;              title: &quot;提示&quot;,              content:                &quot;当前版本过低，无法使用 measureText 功能，请升级到最新微信版本后重试。&quot;,            &#125;);            // this.triggerEvent(&#x27;getImage&#x27;, &#123;errMsg: &#x27;canvasdrawer:version too low&#x27;&#125;)            this.$emit(&quot;getImage&quot;, &#123; errMsg: &quot;canvasdrawer:version too low&quot; &#125;);            return;          &#125; else &#123;            this.drawText(views[i]);          &#125;        &#125; else if (views[i].type === &quot;rect&quot;) &#123;          this.drawRect(views[i]);        &#125;      &#125;      this.ctx.draw(false, () =&gt; &#123;        uni.setStorageSync(&quot;canvasdrawer_pic_cache&quot;, this.cache);        const system = uni.getSystemInfoSync().system;        if (/ios/i.test(system)) &#123;          this.saveImageToLocal();        &#125; else &#123;          // 延迟保存图片，解决安卓生成图片错位bug。          setTimeout(() =&gt; &#123;            this.saveImageToLocal();          &#125;, 800);        &#125;      &#125;);    &#125;,    drawImage(params) &#123;      this.ctx.save();      const &#123;        url,        top = 0,        left = 0,        width = 0,        height = 0,        borderRadius = 0,        deg = 0,      &#125; = params;      if (deg !== 0) &#123;        this.ctx.translate(left + width / 2, top + height / 2);        this.ctx.rotate((deg * Math.PI) / 180);        this.ctx.drawImage(url, -width / 2, -height / 2, width, height);      &#125; else &#123;        this.ctx.beginPath();        this.ctx.arc(left, top, borderRadius, 0, 2 * Math.PI, false);        this.ctx.fillStyle = &quot;#9fd9ef&quot;;        this.ctx.fill();        this.ctx.lineWidth = 1;        this.ctx.strokeStyle = &quot;#00477d&quot;;        this.ctx.stroke();        this.ctx.drawImage(url, left, top, width, height);      &#125;      this.ctx.restore();    &#125;,    drawText(params) &#123;      this.ctx.save();      const &#123;        MaxLineNumber = 2,        breakWord = false,        color = &quot;black&quot;,        content = &quot;&quot;,        fontSize = 16,        top = 0,        left = 0,        lineHeight = 20,        textAlign = &quot;left&quot;,        width,        bolder = false,        textDecoration = &quot;none&quot;,      &#125; = params;      this.ctx.beginPath();      this.ctx.setTextBaseline(&quot;top&quot;);      this.ctx.setTextAlign(textAlign);      this.ctx.setFillStyle(color);      this.ctx.setFontSize(fontSize);      if (!breakWord) &#123;        this.ctx.fillText(content, left, top, width);        this.drawTextLine(left, top, textDecoration, color, fontSize, content);      &#125; else &#123;        let fillText = &quot;&quot;;        let fillTop = top;        let lineNum = 1;        for (let i = 0; i &lt; content.length; i++) &#123;          fillText += [content[i]];          if (this.ctx.measureText(fillText).width &gt; width) &#123;            if (lineNum === MaxLineNumber) &#123;              if (i !== content.length) &#123;                fillText = fillText.substring(0, fillText.length - 1) + &quot;...&quot;;                this.ctx.fillText(fillText, left, fillTop);                this.drawTextLine(                  left,                  fillTop,                  textDecoration,                  color,                  fontSize,                  fillText                );                fillText = &quot;&quot;;                break;              &#125;            &#125;            this.ctx.fillText(fillText, left, fillTop);            this.drawTextLine(              left,              fillTop,              textDecoration,              color,              fontSize,              fillText            );            fillText = &quot;&quot;;            fillTop += lineHeight;            lineNum++;          &#125;        &#125;        this.ctx.fillText(fillText, left, fillTop);        this.drawTextLine(          left,          fillTop,          textDecoration,          color,          fontSize,          fillText        );      &#125;      this.ctx.restore();      if (bolder) &#123;        this.drawText(&#123;          ...params,          left: left + 0.3,          top: top + 0.3,          bolder: false,          textDecoration: &quot;none&quot;,        &#125;);      &#125;    &#125;,    drawTextLine(left, top, textDecoration, color, fontSize, content) &#123;      if (textDecoration === &quot;underline&quot;) &#123;        this.drawRect(&#123;          background: color,          top: top + fontSize * 1.2,          left: left - 1,          width: this.ctx.measureText(content).width + 3,          height: 1,        &#125;);      &#125; else if (textDecoration === &quot;line-through&quot;) &#123;        this.drawRect(&#123;          background: color,          top: top + fontSize * 0.6,          left: left - 1,          width: this.ctx.measureText(content).width + 3,          height: 1,        &#125;);      &#125;    &#125;,    drawRect(params) &#123;      this.ctx.save();      const &#123; background, top = 0, left = 0, width = 0, height = 0 &#125; = params;      this.ctx.setFillStyle(background);      this.ctx.fillRect(left, top, width, height);      this.ctx.restore();    &#125;,    getImageInfo(url) &#123;      return new Promise((resolve, reject) =&gt; &#123;        if (this.cache[url]) &#123;          resolve(this.cache[url]);        &#125; else &#123;          const objExp = new RegExp(            /^http(s)?:\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- .\\/?%&amp;=]*)?/          );          if (objExp.test(url)) &#123;            uni.getImageInfo(&#123;              src: url,              complete: (res) =&gt; &#123;                if (res.errMsg === &quot;getImageInfo:ok&quot;) &#123;                  this.cache[url] = res.path;                  resolve(res.path);                &#125; else &#123;                  // this.triggerEvent(&#x27;getImage&#x27;, &#123;errMsg: &#x27;canvasdrawer:download fail&#x27;&#125;)                  this.$emit(&quot;getImage&quot;, &#123;                    errMsg: &quot;canvasdrawer:download fail&quot;,                  &#125;);                  reject(new Error(&quot;getImageInfo fail&quot;));                &#125;              &#125;,            &#125;);          &#125; else &#123;            this.cache[url] = url;            resolve(url);          &#125;        &#125;      &#125;);    &#125;,    saveImageToLocal() &#123;      const width = this.width;      const height = this.height;      uni.canvasToTempFilePath(        &#123;          x: 0,          y: 0,          width,          height,          canvasId: this.name,          complete: (res) =&gt; &#123;            if (res.errMsg === &quot;canvasToTempFilePath:ok&quot;) &#123;              this.showCanvas = false;              this.isPainting = false;              this.tempFileList = [];              this.$emit(&quot;getImage&quot;, &#123;                tempFilePath: res.tempFilePath,                errMsg: &quot;canvasdrawer:ok&quot;,              &#125;);            &#125; else &#123;              this.$emit(&quot;getImage&quot;, &#123; errMsg: &quot;canvasdrawer:fail&quot; &#125;);            &#125;          &#125;,        &#125;,        this      );    &#125;,  &#125;,&#125;;&lt;/script&gt;&lt;style&gt;.board &#123;  position: fixed;  top: 2000rpx;&#125;&lt;/style&gt;\n","slug":"Dcloud的Canvas插件二次改写为Vue模板","date":"2021-06-30T16:00:00.000Z","categories_index":"uni-app","tags_index":"uni-app,canvas","author_index":"谢小谢"},{"id":"cbaa866e1d73edd3734c218b3bd40e4c","title":"安卓IOS应用桥接js","content":"记录下自己公司和 js 友商的 APP 桥接的过程 ## 代码展示\n123456789101112131415161718192021222324252627282930313233343536373839404142// 环境判断const isAndroid = navigator.userAgent.indexOf(&#x27;Android&#x27;) &gt; -1 || navigator.userAgent.indexOf(&#x27;Adr&#x27;) &gt; -1;// 初始化桥接function initBridge(callback) &#123;  if (isAndroid) &#123;    /**安卓端创建桥接*/    if (window.WebViewJavascriptBridge) &#123;      callback(WebViewJavascriptBridge);    &#125; else &#123;      document.addEventListener(        &quot;WebViewJavascriptBridgeReady&quot;,        function () &#123;          callback(WebViewJavascriptBridge);        &#125;,        false      );    &#125;  &#125; else &#123;    /**苹果端创建桥接*/    if (window.WebViewJavascriptBridge) &#123;      return callback(WebViewJavascriptBridge);    &#125;    if (window.WVJBCallbacks) &#123;      return window.WVJBCallbacks.push(callback);    &#125;    window.WVJBCallbacks = [callback];    const WVJBIframe = document.createElement(&quot;iframe&quot;);    WVJBIframe.style.display = &quot;none&quot;;    WVJBIframe.src = &quot;wvjbscheme://__BRIDGE_LOADED__&quot;;    document.documentElement.appendChild(WVJBIframe);    setTimeout(function () &#123;      document.documentElement.removeChild(WVJBIframe);    &#125;, 0);  &#125;&#125;initBridge((bridge) =&gt; &#123;  // 调用Native方法  bridge.callHandler(方法名, 参数, (res) =&gt; &#123;...执行对应操作&#125;);  // 注册方法  bridge.registerHandler(方法名, (res) =&gt; &#123;...执行对应操作&#125;);&#125;);\n","slug":"安卓IOS应用桥接js","date":"2021-02-24T16:00:00.000Z","categories_index":"","tags_index":"APP","author_index":"谢小谢"},{"id":"042d33a635bea50f9dee5448c961536b","title":"组件库按需加载声明文件(d.ts)编写","content":"前言自己的 Fat-ui 组件库和 babel 按需加载插件写完之后，也抽空把 d.ts 声明文件一起做了，现在将编写和配置过程记录下来\n第一步 首先分析下 Vue3 插件注册时的部分源代码1234567891011121314151617181920212223// 文件地址： vue-next/packages/runtime-core/src/apiCreateApp.ts// 创建一个存储所有插件的列表const installedPlugins = new Set()// use方法使用插件use(plugin: Plugin, ...options: any[]) &#123; // 如果列表里面已经注册了 那么就提示 if (installedPlugins.has(plugin)) &#123;   __DEV__ &amp;&amp; warn(`Plugin has already been applied to target app.`)  // 如果插件的install是一个函数 那么推入插件列表 并且直接执行install &#125; else if (plugin &amp;&amp; isFunction(plugin.install)) &#123;  installedPlugins.add(plugin)  plugin.install(app, ...options)  // 如果插件是一个函数 那么也是直接执行 因为插件注册有2种方式  // 1.对象里面带install函数  // 2.函数  &#125; else if (isFunction(plugin)) &#123;    installedPlugins.add(plugin)    plugin(app, ...options)  &#125; else if (__DEV__) &#123;  &#125;  return app&#125;\n\n从上图可知插件里面需要注册一个 install 方法\n第二步 首先需要定义全局组件注册的 d.ts1234567index.d.ts import &#123; App &#125; from &#x27;vue&#x27;// 定义了一个classexport class FatComponent &#123;  static name: string// 传入App实例static install: (app: App) =&gt; any &#125;export class button extends FatComponent &#123;&#125;\n\n第三步通过上面的 d.ts 编写后 就可以直接在 package.json 的 typings 指定声明文件的地址了, 声明之后就可以直接打包\n1&#123; &quot;typings&quot;: &quot;types/index.d.ts&quot;,   ... &#125;\n","slug":"组件库按需加载声明文件(d.ts)编写","date":"2021-02-22T16:00:00.000Z","categories_index":"库相关,经验","tags_index":"Vue,组件库","author_index":"谢小谢"},{"id":"5355fae89eaca8d398dfae233dd715c4","title":"定制自己的 Fat-ui 组件库之如何编写自己的按需加载 babel 插件","content":"作为一名前端开发工程师 我一直想拥有自己的一套组件库，最近把 Fat-ui 的几个组件已经完成，现在将之前的按需加载 babel 插件编写过程记录下来\n\n\n\n\n\n\n\n\n\n可以下载我的 babel-plugin-dynamic 库\n查看代码：npm i babel-plugin-dynamic -D\n\n\n\n\n\n\n\n\n\nTip: 对下文不懂的可以参考babel插件入门\n本质按需加载原理其实就是运用 commonjs 单独引入打包后的 js 文件和 css 文件，代码转换如下123// 参照我自己的Fat-ui组件 转换前import &#123; cell &#125; from &quot;fat-ui&quot;;// 转换后var cell = require(&#x27;fat-ui/lib/cell&#x27;)require(&#x27;fat-ui/style/cell.css&#x27;)\n\n了解 babel 编译过程babel 编译过程分为三个阶段：&gt; 源代码 -&gt; AST -&gt; 转换过的 AST -&gt; 转换过的代码\n转换过程对应着几个不同的包,而这些包都包含在@babel&#x2F;core 核心包内\n\n@babel&#x2F;parser：解析 js 代码,转换成 AST 语法\n@babel&#x2F;traverse：遍历 AST 语法，对 AST 进行遍历操作，生成新的 AST\n@babel&#x2F;generator：把 AST 代码转换成 js 代码\n@babel&#x2F;types：提供的一个工具函数来创建一个 AST 节点\n\n开始写代码先看源代码转换成 AST 前后的样子1234567891011121314151617181920212223242526272829303132333435363738394041// 转换前import &#123; cell, dialog &#125; from &#x27;fat-ui&#x27;// 转换后&#123;  type: &quot;Program&quot;,  start: 0,  end: 37,  body: [    &#123;      type: &quot;ImportDeclaration&quot;,      start: 0,      end: 37,      specifiers: [        &#123;          type: &quot;ImportSpecifier&quot;,          start: 9,          end: 13,          imported: &#123; type: &quot;Identifier&quot;, start: 9, end: 13, name: &quot;cell&quot; &#125;,          local: &#123; type: &quot;Identifier&quot;, start: 9, end: 13, name: &quot;cell&quot; &#125;,        &#125;,        &#123;          type: &quot;ImportSpecifier&quot;,          start: 15,          end: 21,          imported: &#123; type: &quot;Identifier&quot;, start: 15, end: 21, name: &quot;dialog&quot; &#125;,          local: &#123; type: &quot;Identifier&quot;, start: 15, end: 21, name: &quot;dialog&quot; &#125;,        &#125;,      ],      source: &#123;        type: &quot;Literal&quot;,        start: 29,        end: 37,        value: &quot;fat-ui&quot;,        raw: &quot;&#x27;fat-ui&#x27;&quot;,      &#125;,    &#125;,  ],  sourceType: &quot;module&quot;,&#125;;\n\n从上图可以分析得出\n\nImportDeclaration：import 语句定义\nImportSpecifier：cell,dialog 括号语句定义\nIdentifier：括号内语句定义内容\nsource 下面的 Literal： 源包名称\n\n根据这一我们可以编写自己的转换逻辑,123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const t = require(&quot;@babel/types&quot;);/*  访问者是一个用于 AST 遍历的跨语言的模式。 简单的说它们就是一个对象，定义了用于在一个树状结构中获取具体节点的方法*/const visitor = &#123;  // 当在树中遇见一个 ImportDeclaration 的时候会调用ImportDeclaration()  ImportDeclaration(path, &#123; opts &#125;) &#123;    const &#123; node &#125; = path;    // babel配置文件时传入的自定义参数    const frameworkName = node.source.value;    let requireStr = [];    // 判断当前框架是否是配置的指定框架 并且节点树的第一个导入是否是模块导入而不是默认导入    if (      frameworkName === opts.frameworkName &amp;&amp;      node.specifiers[0].type === &quot;ImportSpecifier&quot; &amp;&amp;      node.specifiers.map((item) =&gt; t.isImportSpecifier(item))    ) &#123;      node.specifiers.forEach((item, index) =&gt; &#123;        if (index === 0) &#123;        &#125;        // 生成require语句        requireStr.push(          t.VariableDeclaration(&quot;var&quot;, [            t.VariableDeclarator(              t.Identifier(item.imported.name),              t.callExpression(t.identifier(&quot;require&quot;), [                t.stringLiteral(                  `$&#123;frameworkName&#125;/lib/$&#123;item.imported.name.toLowerCase()&#125;`                ),              ])            ),          ])        );        requireStr.push(          t.callExpression(t.identifier(&quot;require&quot;), [            t.stringLiteral(              `$&#123;frameworkName&#125;/lib/style/$&#123;item.imported.name.toLowerCase()&#125;.css`            ),          ])        );      &#125;);      // 替换语句      path.replaceWithMultiple(requireStr);    &#125;  &#125;,&#125;;// 作为一个common.js模块导出module.exports = function () &#123;  return &#123;    // 访问者模 visitor  &#125;;&#125;;\n\npackage.json 发布包1&#123;  ...  &quot;main&quot;: &quot;index.js&quot;,  ...&#125;\n\n使用 babel.config.js 引用1module.exports = &#123; plugins: [[&quot;dynamic&quot;, &#123; frameworkName: &quot;fat-ui&quot; &#125;]] &#125;;\n","slug":"定制自己的 Fat-ui 组件库之如何编写自己的按需加载 babel 插件","date":"2021-02-21T16:00:00.000Z","categories_index":"经验","tags_index":"babel","author_index":"谢小谢"},{"id":"8cb79cbb342e1af117a4deecc4477305","title":"Vue下使用better-scroll触发click事件触发2次的解决方法","content":"最近在做公司项目的时候遇到了一个很奇怪的 bug, 当前页为一个 better-scroll 页面 当跳转到下一个页面再返回再跳转时 一次点击事件触发了 2 次。原因: better-scroll 第二次初始化时第一次的实例未卸载导致\n解决思路 在第二次重新初始化时把 click 配置项改为 false123456789101112export default &#123;  methods: &#123;    _initScroll(bool) &#123;      const _self = this;      _self.listBscroll = new BScroll(&quot;.list-wrapper&quot;, &#123;        probeType: 1,        click: bool,        pullUpLoad: &#123; threshold: -30 &#125;,      &#125;);    &#125;,  &#125;,&#125;;\n","slug":"Vue下使用better-scroll触发click事件触发2次的解决方法2020-09-14","date":"2020-09-13T16:00:00.000Z","categories_index":"Vue,总结","tags_index":"better-scroll","author_index":"谢小谢"},{"id":"3579d33c3390fb8f737ed089f4ee848a","title":"Vue动态组件打包实测","content":"记录一次关于 Vue 动态组件打包的异同\n未使用异步组件的打包情况12345&lt;script&gt;import HelloWorld from &quot;./components/HelloWorld.vue&quot;;import Demo from &quot;./components/demo.vue&quot;;export default &#123; components: &#123; HelloWorld, Demo &#125; &#125;;&lt;/script&gt;\n\n12345678910111213141516File                                 Size               Gzipped  \tdist\\\\js\\\\chunk-vendors.3cdd9400.js    89.10 KiB          31.92 KiB \tdist\\\\js\\\\app.13046f3b.js              7.08 KiB           1.77 KiB \tdist\\\\css\\\\app.1d736950.css            0.51 KiB           0.25 KiB ```## 使用异步组件后的打包情况```js&lt;script&gt;import HelloWorld from &quot;./components/HelloWorld.vue&quot;;import Demo from &quot;./components/demo.vue&quot;;export default &#123; components: &#123;   HelloWorld: () =&gt; import(&quot;./components/HelloWorld.vue&quot;),   Demo: () =&gt; import(&quot;./components/demo.vue&quot;), &#125;,&#125;;&lt;/script&gt;\n\n打包后的文件夹情况\n12345678File                        Size          Gzippeddist\\js\\chunk-vendors.49d7da52.js 89.34 KiB 31.98 KiBdist\\js\\app.71ab26fc.js 4.18 KiB 1.94 KiBdist\\js\\chunk-b3235d12.e2a9d657.js 2.58 KiB 0.79 KiBdist\\js\\chunk-c7bea068.5f268e60.js 2.58 KiB 0.79 KiBdist\\css\\chunk-b3235d12.22b7f024.css 0.17 KiB 0.13 KiBdist\\css\\chunk-c7bea068.0f5084a9.css 0.17 KiB 0.13 KiBdist\\css\\app.6af8ca07.css 0.16 KiB 0.14 KiB\n\n实际区别可以看到, Demo 组件和 HelloWorld 组件被分割了出来, 生成了两个 chunk 文件, 在编写代码逻辑时可以针对这两个组件进行延迟加载, 从而减少首屏的载入时间\n","slug":"Vue动态组件打包实测","date":"2020-09-13T16:00:00.000Z","categories_index":"webpack,总结","tags_index":"webpack","author_index":"谢小谢"},{"id":"baf239d953fd03e4fb1a47a4e7060466","title":"记一次企业微信WX JS-SDK的不同设备下的问题","content":"问题记录: 最近在一次企业微信的 jssdk 的调用过程中发现 IOS 设备下在功能页初始化配置微信 js-sdk 无效。\n解决方法: Android 下获取微信 js-sdk 配置只需传 window.href。 IOS 下传 location.href.split( ‘# ‘)[0] ### 方法封装 #### 对微信 js-sdk 初始化进行配置\n1234567891011121314151617181920212223242526272829import wx from &quot;weixin-js-sdk &quot;;import &#123; getWxJssdk &#125; from &quot;@/api/customer &quot;;/* \t* 判断是否IOS环境 \t* */export function isIOS() &#123;  let isIphone = navigator.userAgent.includes(&quot;iPhone &quot;);  let isIpad = navigator.userAgent.includes(&quot;iPad &quot;);  return isIphone || isIpad;&#125;/** 获取微信签名，注入权限验证配置 \t* */export async function requestWxStr() &#123;  let url = isIOS() ? location.href.split(&quot;# &quot;)[0] : location.href;  var params = &#123; &quot;localUrl &quot;: location.href.split(&quot;# &quot;)[0] &#125;;  try &#123;    let res = await getWxJssdk(&#123; url &#125;);    if (res.signature) &#123;      wx.config(&#123;        beta: true, // 必须这么写，否则wx.invoke调用形式的jsapi会有问题        debug: true,        appId: res.signature.appId,        timestamp: res.signature.timestamp, // 必填，生成签名的时间戳        nonceStr: res.signature.nonceStr, // 必填，生成签名的随机串        signature: res.signature.signature, // 必填，签名，见 附录-JS-SDK使用权限签名算法        jsApiList: [&quot;onMenuShareWechat &quot;, &quot;shareWechatMessage &quot;],      &#125;);    &#125;  &#125; catch (e) &#123;    throw e;  &#125;&#125;\n\n路由初始化时判断设备类型进行配置1234567router.beforeEach((to, from, next) =&gt; &#123;  if (isIOS()) &#123;    if (from.path === &quot;/&quot;) &#123;      requestWxStr(); //该函数和之前一样，被单独提取出来了    &#125;  &#125;&#125;);\n\n功能页如果不是 IOS 页面就初始化12345created() &#123;  if (!isIOS()) &#123;    requestWxStr();  &#125;&#125;\n\n1\n","slug":"记一次企业微信WX JS-SDK的不同设备下的问题","date":"2020-09-13T16:00:00.000Z","categories_index":"经验","tags_index":"canvas,js-sdk","author_index":"谢小谢"},{"id":"977046a105528b08c6104c9e8e95e023","title":"HTTP缓存机制记录","content":"http 缓存机制很容易就忘记了 这里大概记录一下\n简单概括http 缓存分为强缓存(Cache-Control &gt; Expires),协商缓存(Etag &#x2F; If-None-Match &gt; Last-Modified &#x2F; If-Modified-Since)强缓存和协商缓存的区别&gt; 强缓存命中的情况下不和服务器做交互，协商缓存不管有没有命中都会和服务器做交互\n第一次请求\n浏览器发起 http 请求到服务器。\nhttp 请求通过浏览器缓存，浏览器缓存没有发现该请求的缓存标识和缓存结果，会直接放行，让 http 请求直接请求到服务器。\n服务器返回请求结果和缓存规则给浏览器\n浏览器将请求结果和缓存标识存入浏览器缓存中，作为下一次请求的标识\n\n第二次请求命中强缓存的情况\nExpires 该字段作为缓存标志， 如果客户端的时间小于 Expires 的值时，就直接使用缓存结果，但是这只是存在于 HTTP&#x2F;1.0 中，现今大部分已经被 Cache-Control 所替代\nCache-Control HTTP1.1 所使用的标识，该字段有以下几种属性\npublic：所有内容都将被缓存（客户端和代理服务器都可缓存）\nprivate：所有内容只有客户端可以缓存，Cache-Control 的默认取值\nno-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定\nno-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存\nmax-age&#x3D;xxx (xxx is numeric)：缓存内容将在 xxx 秒后失效\n\n第二次请求\n强缓存未命中，协商缓存命中的情况当协商缓存命中时，服务器返回 304 状态码表示该资源没有更新协商缓存字段有 Last-Modified &#x2F; If-Modified-Since 和 Etag &#x2F; If-None-Match，其中 Etag &#x2F; If-None-Match 的优先级比 Last-Modified &#x2F; If-Modified-Since 高。\nIf-None-Match&#x2F;Etag &#x3D;&gt; 客户端再次发起该请求时，携带上次请求返回的唯一标识 Etag 值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有 If-None-Match，则会根据 If-None-Match 的字段值与该资源在服务器的 Etag 值做对比，一致则返回 304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，返回 200\nLast-Modified&#x2F;If-Modified-Since &#x3D;&gt; 则是客户端再次发起该请求时，携带上次请求返回的 Last-Modified 值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有 If-Modified-Since 字段，则会根据 If-Modified-Since 的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于 If-Modified-Since 的字段值，则重新返回资源，状态码为 200；否则则返回 304，代表资源无更新，可继续使用缓存文件\n\n","slug":"HTTP缓存机制记录","date":"2019-12-03T16:00:00.000Z","categories_index":"http,总结","tags_index":"http","author_index":"谢小谢"},{"id":"f88c08d2432ee83789750b7f28e6e54e","title":"DockerCompose一键配置nginx,mysql环境","content":"之前一直觉得把 mysql 和 nginx 环境分别分开部署很不好，一旦服务器宕机，又得找到对应的目录开启对应的指令，后面发现了 docker 可以用来一次性部署环境，但是也有缺点，服务器宕机的情况下 Mysql 容器里面的数据就会丢失，正好 docker-compose 可以解决这个问题，在这里记录下自己的部署过程。\n前期准备docker 环境安装(这部分自行百度)安装完毕就直接拉取镜像\n\n\n\n\n\n\n\n\n\ndocker pull mysql:5.6docker pull nginx:latest\n开始正式配置docker-compose.yml 在自己配置好的 docker 文件夹下(推荐)，创建 docker-compose.yml\n\n\n\n\n\n\n\n\n\ntouch docker-compose.yml 编辑 docker-compose.ymlvim docker-compose.yml 粘贴配置文件\n123456789101112131415nginx:  image: nginx:latest  ports:    - \\&quot;80:80\\&quot;  volumes:    - ./nginx/conf/nginx.conf:/etc/nginx/nginx.conf:ro  mysql:  restart: always  image: mysql:5.6  volumes:    - ./mysql:/var/lib/mysql  ports:    - 3306:3306  environment:   MYSQL_ROOT_PASSWORD: \\&quot;your_mysql_password\\&quot;\n\n说明: _ image 代表所要启动的镜像名称_ ports 为当前镜像所启动的映射端口* volumes 下方配置 分号左边为本地的路径，分号右边为原始配置路径，即使用当前路径替换原始配置路径达到自定义的效果* MYSQL_ROOT_PASSWORD 为初始化的 mysql 密码之前后就可以在当前目录下创建 mysql 文件夹和 nginx 文件夹，nginx 文件夹下创建 conf 文件夹并在 conf 下创建 nginx.conf 配置文件\n开始配置nginx.conf 文件这里需要注意 upstream 里面的域名不能直接使用 localhost&#x2F;127.0.0.1 因为 docker 下是无法访问外部宿主机 需要使用指令桥接替换本地 ip 指向，输入以下指令就可以直接使用 192.168.0.1 来指代本地 ip\n\n\n\n\n\n\n\n\n\ndocker network create -d bridge –subnet 192.168.0.0&#x2F;24 –gateway 192.168.0.1 localNet\n开始构建 docker 容器在 docker 文件夹下输入构建指令\n\n\n\n\n\n\n\n\ndocker-compose up -d\n如果提示如下，那么就成功构建   docker_mysql_1 is up-to-date  docker_nginx_1 is up-to-date构建完直接开启服务\n\n\n\n\n\n\n\n\n\ndocker-compose start &#x2F;&#x2F; 开启服务\n","slug":"DockerCompose一键配置nginx,mysql环境","date":"2019-12-02T16:00:00.000Z","categories_index":"docker部署","tags_index":"nginx,docker","author_index":"谢小谢"},{"id":"e7f5e465a1dcc0e0547db7a3cbc7589e","title":"如何在Linux环境部署Node.js环境","content":"博客即将部署, 在这里记录下自己 node 环境的配置方法\n第一步进入Node 官网下载页，chrome 按下 F12 进入控制台，点击元素获取下载连接\\n 或者也可以通过 QQ 浏览器自带的下载器,点击右键提取下载链接\n第二步使用 Centos(或者其他 linux 服务器)的 wget 命令，如果没有 wget 命令就使用自带的 yum 命令下载 wget(如下)&gt; yum install -y wget 下载完 wget 之后就可以直接下载 Node&gt; wget https://npm.taobao.org/mirrors/node/v12.13.1/node-v12.13.1-linux-x64.tar.xz\n第三步使用 tar 命令解压安装包&gt; tar -xvf node-v12.13.1-linux-x64.tar.xz\n第四步直接使用软连接方式全局配置 Node 和 npm js\\nln -s /usr/local/nodejs/bin/npm /usr/local/bin/\\nln -s /usr/local/nodejs/bin/node /usr/local/bin/\\n\n第五步控制台直接 node -v 或者 npm -v 打印 Node 版本\n","slug":"如何在Linux环境部署Node.js环境","date":"2019-12-02T16:00:00.000Z","categories_index":"经验","tags_index":"linux","author_index":"谢小谢"},{"id":"c56ee70c55fbd1ff18b7573952b52a52","title":"CSS多行溢出处理","content":"前言之前做过的布局文字溢出效果 一段时间不用之后就老是忘记 今天记录下来\n单行溢出123overflow: hidden;text-overflow: ellipsis;white-space: nowrap;\n\n多行溢出(webkit)1234overflow: hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 2; // 在第几行处省略-webkit-box-orient: vertical;\n","slug":"CSS多行溢出处理","date":"2019-10-02T16:00:00.000Z","categories_index":"CSS样式","tags_index":"CSS,SCSS","author_index":"谢小谢"}]