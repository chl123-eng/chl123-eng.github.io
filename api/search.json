[{"id":"fc0084e39f16c44f947668a585ecf5c2","title":"旧版本Vuex如何做持久化","content":"怎么实现vuex的持久化缓存Vuex持久化缓存通常指的是将Vuex中的state状态保存到本地存储中，这样即使在页面刷新或关闭后，重新打开页面仍然可以恢复之前的状态。实现Vuex持久化缓存有几种不同的方法，以下是一些常见的实现方式：\n使用localStorage或sessionStorage我们可以手动将Vuex的state序列化后保存到localStorage或sessionStorage中，并在应用启动时从存储中恢复状态。\n12345678910111213141516171819202122232425262728293031// 保存state到localStoragefunction saveToStorage(state) &#123;  localStorage.setItem(&#x27;vuex-state&#x27;, JSON.stringify(state));&#125;​// 从localStorage恢复statefunction loadFromStorage() &#123;  const storedState = localStorage.getItem(&#x27;vuex-state&#x27;);  return storedState ? JSON.parse(storedState) : &#123;&#125;;&#125;​// 在Vuex的mutations中使用const mutations = &#123;  saveState(state) &#123;    saveToStorage(state);  &#125;&#125;;​// 在Vuex的actions中恢复stateconst actions = &#123;  restoreState(&#123; commit &#125;) &#123;    const savedState = loadFromStorage();    if (Object.keys(savedState).length) &#123;      commit(&#x27;hydrateState&#x27;, savedState);    &#125;  &#125;&#125;;​// 在组件中或在应用启动时调用恢复state的actiondispatch(&#x27;restoreState&#x27;);\n\n快速使用：vuex-persist插件npm install vuex-persist，然后，在我们的Vuex store中使用这个插件：\n12345678910111213141516171819javascript复制代码import Vue from &#x27;vue&#x27;;import Vuex from &#x27;vuex&#x27;;import vuexPersist from &#x27;vuex-persist&#x27;;​Vue.use(Vuex);​const store = new Vuex.Store(&#123;  // ...我们的state, mutations, actions等&#125;);​const vuexPersist = new vuexPersist(&#123;  key: &#x27;vuex&#x27;, // 存储的名称  storage: window.localStorage, // 存储方式，可以选择sessionStorage或localStorage  // 其他配置...&#125;);​// 使用插件vuexPersist.plugin(store);\n\n注意\n\n序列化: 当我们将state保存到本地存储时，确保state中的数据可以被序列化。这意味着state中不应该包含函数、undefined等不能被JSON序列化的数据。\n安全性: 存储在localStorage或sessionStorage中的数据可以被同源的任何JavaScript代码访问，因此不要存储敏感信息。性能: 避免频繁地读写本地存储，因为这可能会影响性能。\n\nvuex-persist 插件扩展vuex-persist是一个第三方Vuex插件，它提供了一种简便的方式来持久化Vuex的状态。这个插件的实现基于几个关键步骤：\n\n序列化状态: 插件首先会将Vuex store的状态（state）序列化成JSON字符串。这是通过JSON.stringify()实现的，确保状态对象中所有的数据都是可以被序列化的。\n存储状态: 序列化后的状态字符串被保存到浏览器的localStorage或sessionStorage中。vuex-persist允许我们通过配置来选择使用哪一种存储方式。监听状态变化: 插件会监听Vuex store的状态变化。每当状态发生变化时，插件都会自动将新的状态序列化并更新到本地存储中。这通常是通过订阅Vuex store的mutation事件来实现的。\n恢复状态: 当应用启动或者需要从持久化存储中恢复状态时，插件会从localStorage或sessionStorage中读取状态字符串，并使用JSON.parse()将其解析回原始的对象结构。\n自动恢复: vuex-persist通常在Vuex store初始化时自动执行状态恢复的逻辑。这意味着在我们的应用启动时，如果本地存储中有保存的状态，vuex-persist会自动恢复这些状态。\n配置选项: vuex-persist提供了多种配置选项，允许我们定制化持久化的行为。例如，我们可以配置要持久化的state片段（通过paths选项），或者设置一个函数来在保存之前过滤状态（通过reducer选项）。\n版本控制: 插件还可以处理版本控制问题，如果我们的应用升级后state结构发生了变化，vuex-persist可以通过配置（如reducer函数）来确保向后兼容。\n集成Vuex严格模式: 当Vuex store配置为严格模式时，vuex-persist能够确保所有状态的变更都是通过mutations进行的，即使这些变更是由插件自身触发的。\n\n","slug":"Vuex本地持久化","date":"2024-02-10T16:00:00.000Z","categories_index":"","tags_index":"Vue,Vuex","author_index":"May"},{"id":"be8b20988d64ed90b36f55c5730a76e9","title":"记一次uni-app原生应用高德地图配置的坑","content":"前言为配合打荷生鲜 2.0 小程序的发展，需要对配送人员增加一个类似于美团骑手版的安卓 App，为此需要引入高德地图的 sdk，折腾了我一天的时候，为此将遇到的问题记录下来\n新开项目如何引用 uni-app 原生插件？\n创建新项目，记录下 appId\n将新项目与第三方插件绑定\n项目配置再次进行绑定\n\n至此，插件的初步使用已经完成\n如何结合高德地图 sdk？\n登录 DCloud 开发者中心，我的应用，应用信息-&gt;各平台信息，记下包名&#x2F;appid，应用信息-&gt;Android 云端证书-&gt;证书详情，记下证书的别名， SHA1 码，密码，并把证书下载到本地\n前往高德地图控制台-&gt;应用管理-&gt;我的应用-&gt;创建应用，配置应用的 packageName 和 SHA1 码一定要和 Dcloud 的证书一致，不一致的话，基座打包后调用 api 会报 ERROR_CODE:7 错误\n创建应用配置完，回到列表拿到应用的 key，回填到 uni-app 项目配置中\n基座打包，填写包名，证书别名，密码，上传证书，开始进行打包\n真机调试，打开 Hbuilder&#x2F;Hbuilderx-&gt;运行-&gt;运行到手机或模拟器-&gt;运行到 Android App 基座-&gt; 使用自定义基座运行\n\n总结主要的坑点还是在 packageName 包名那块，官方也没说明怎么生成 SHA1 码，于是就自己用 keytool 自己生成了，结果显而易见，一直卡在那边，通过慢慢结合网上摸索才得出解决办法。\n","slug":"记一次uni-app原生应用高德地图配置的坑","date":"2023-11-15T16:00:00.000Z","categories_index":"经验","tags_index":"原生小程序,高德地图","author_index":"May"},{"id":"0f52401eaa7baffae19fe63567938437","title":"uni-app微信小程序实现axios请求拦截器和重复请求中断","content":"最近在写二手表微信小程序的时候，发现老是会有重复请求的情况，用了函数防抖和布尔拦截之后，又显得非常臃肿，没能从根本上解决问题，刚好 leader 叫我做一下重复请求拦截。可是，当我翻开 flyio 文档之后……\nWhat the fuck没想到 flyio 竟然没有预设重复请求功能，绝望\n\n当前目标和处理思路那么我的目标就变成了兼容旧 flyio 的拦截器功能，并且还要实现重复请求拦截功能。对接重复请求拦截，因为我们当前小程序只有微信端，那我就直接换成了微信小程序官方的请求，刚好也有请求中断功能。对于拦截器，基本都是通过 promise 来实现的，那这里就直接自己写一个。\n请求和响应拦截的思路通过 Promise.then 实现链式的串行调用，因为前置有请求拦截器，后置有响应拦截器，中间插入请求结构体。整体结构如下图\n\n代码细究整体工具库使用 lodash\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142export const callFor = (arrayData, fn) =&gt; &#123;  arrayData.forEach(item =&gt; &#123;    fn.call(null, item)  &#125;)&#125;// 全局拦截器实例export default class Interceptor &#123;  constructor() &#123;    this.handlers = []  &#125;  // use方法传入Promise两个状态处理语句  use(fulfilled, rejected) &#123;    this.handlers.push(&#123;      fulfilled,      rejected    &#125;)    return this.handlers.length - 1  &#125;&#125;// 主体请求参数 作为promise调用链的入参之一const requestFn = config =&gt; &#123;  const options = config  // requestTaskKey 当前重复请求的url标识  let lastRequestKey = config.hasOwnProperty(&#x27;requestTaskKey&#x27;) ? config.requestTaskKey : &#x27;&#x27;  // 如果全局变量数组里面含有当前的请求，那么就直接中断上一次请求  if (    lastRequestKey &amp;&amp;    getApp().hasOwnProperty(&#x27;requestTasks&#x27;) &amp;&amp;    getApp().requestTasks.hasOwnProperty(lastRequestKey)  ) &#123;    try &#123;      console.log(&#x27;中断了上一次的请求----------------------&#x27;)      getApp().requestTasks[lastRequestKey].abort()      // 中断后就应该清除掉      delete getApp().requestTasks[lastRequestKey]    &#125; catch (e) &#123;      console.error(e)    &#125;  &#125;  // 返回一个promise  return new Promise((resolve, reject) =&gt; &#123;    const url = options.baseURL + options.url    options.url = url    const requestTask = uni.request(&#123;      ...options,      complete: res =&gt; &#123;        console.log(res)        // 每一次成功之后 就清空当前url在全局变量数组里面的位置        // request:faile abort为公司自定义的错误请求状态，        if (res.errMsg !== &#x27;request:faile abort&#x27; &amp;&amp; lastRequestKey) &#123;          delete getApp().requestTasks[lastRequestKey]        &#125;        if (res.errMsg === &#x27;request:ok&#x27;) &#123;          return resolve(&#123; ...res, request: options &#125;)        &#125; else if (res.errMsg === &#x27;request:fail&#x27;) &#123;          return reject(&#123; ...res, request: options &#125;)        &#125;      &#125;    &#125;)    // 如果当前请求需要支持重复请求的中断，    if (lastRequestKey) &#123;      // 没有队列的情况下 全局变量存储队列      if (!getApp().requestTasks) &#123;        getApp().requestTasks = &#123;&#125;      &#125;      // 把当前请求塞入存储队列之中      getApp().requestTasks[lastRequestKey] = requestTask    &#125;  &#125;)&#125;function HttpRequest(config) &#123;  // 深拷贝配置防止配置被上一个请求修改  this.config = _.cloneDeep(    Object.assign(      &#123;&#125;,      &#123;        baseURL: &#x27;&#x27;,        url: &#x27;&#x27;,        data: &#123;&#125;,        header: &#123;&#125;,        method: &#x27;GET&#x27;,        timeout: 60000      &#125;,      config    )  )  // 初始化拦截器  this.interceptors = &#123;    request: new Interceptor(),    response: new Interceptor()  &#125;&#125;HttpRequest.prototype.request = function (config = &#123;&#125;) &#123;  const options = Object.assign(&#123;&#125;, this.config, config)  console.log(options)  let requestInterceptorChain = [],    responseInterceptorChain = []  // 推入请求拦截器  this.interceptors.request.forEach(obj =&gt; &#123;    requestInterceptorChain.unshift(obj.fulfilled, obj.rejected)  &#125;)  // 推入响应拦截器  this.interceptors.response.forEach(obj =&gt; &#123;    responseInterceptorChain.push(obj.fulfilled, obj.rejected)  &#125;)  let promise  // 第二个值为undefined是因为要为后面的请求进行补位 这样可以防止流入错误请求  let chain = [requestFn, undefined]  // request请求拦截插入最前方  Array.prototype.unshift.call(chain, ...requestInterceptorChain)  // responese响应插入最后方  chain = chain.concat(responseInterceptorChain)  promise = Promise.resolve(options)  // promise.then串行处理  while (chain.length) &#123;    promise = promise.then(chain.shift(), chain.shift())  &#125;  return promise&#125;// 不同请求格式的差异化处理callFor([&#x27;post&#x27;, &#x27;put&#x27;, &#x27;patch&#x27;], function (methodType) &#123;  HttpRequest.prototype[methodType] = function (url, data = &#123;&#125;, otherConfig = &#123;&#125;) &#123;    const config = Object.assign(&#123;&#125;, &#123; data, url, method: methodType &#125;, otherConfig)    return this.request(config)  &#125;&#125;)callFor([&#x27;delete&#x27;, &#x27;get&#x27;, &#x27;head&#x27;, &#x27;config&#x27;], function (methodType) &#123;  HttpRequest.prototype[methodType] = function (url, params = &#123;&#125;, otherConfig = &#123;&#125;) &#123;    const config = Object.assign(&#123;&#125;, otherConfig, &#123; url, params, method: methodType &#125;)    return this.request(config)  &#125;&#125;)export default HttpRequest\n\n这就是我基于 Prmiose 加小程序重复请求封装的核心代码，这里还未涉及到离开页面时的请求中断行为。不过大概思路的话就是收集所有请求的状态，封装成对象，调用时修改状态，后续有时间我会更加深究这部分的代码，更好地服务于业务。\n","slug":"uni-app微信小程序实现axios请求拦截器和重复请求中断","date":"2022-12-07T16:00:00.000Z","categories_index":"axios,微信小程序","tags_index":"uni-app,http,微信小程序","author_index":"May"},{"id":"b5ff54a9d086ee4b944aa5321b46f563","title":"Vue2.6系列源码解析之Keep-Alive组件的缓存逻辑","content":"对于很多用过 vue 这个框架的人来说，想必都用过 keep-alive 组件缓存功能。vue 内部使用了 LRU 缓存淘汰算法来实现组件的缓存更新问题，那 vue 是如何实现这个 keep-alive 组件的逻辑呢，我们来解析一下。\n源码解读123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153// 获取vnode实例名称function getComponentName(opts: ?VNodeComponentOptions): ?string &#123;  return opts &amp;&amp; (opts.Ctor.options.name || opts.tag);&#125;// 匹配当前队列里面是否存在该vnodefunction matches(  pattern: string | RegExp | Array&lt;string&gt;,  name: string): boolean &#123;  if (Array.isArray(pattern)) &#123;    return pattern.indexOf(name) &gt; -1;  &#125; else if (typeof pattern === &quot;string&quot;) &#123;    return pattern.split(&quot;,&quot;).indexOf(name) &gt; -1;  &#125; else if (isRegExp(pattern)) &#123;    return pattern.test(name);  &#125;  return false;&#125;// 实例筛选function pruneCache(keepAliveInstance: any, filter: Function) &#123;  const &#123; cache, keys, _vnode &#125; = keepAliveInstance;  for (const key in cache) &#123;    const entry: ?CacheEntry = cache[key];    if (entry) &#123;      const name: ?string = entry.name;      if (name &amp;&amp; !filter(name)) &#123;        pruneCacheEntry(cache, key, keys, _vnode);      &#125;    &#125;  &#125;&#125;function pruneCacheEntry(  cache: CacheEntryMap,  key: string,  keys: Array&lt;string&gt;,  current?: VNode) &#123;  const entry: ?CacheEntry = cache[key];  if (entry &amp;&amp; (!current || entry.tag !== current.tag)) &#123;    entry.componentInstance.$destroy();  &#125;  cache[key] = null;  remove(keys, key);&#125;export default &#123;  name: &quot;keep-alive&quot;,  abstract: true,  props: &#123;    include: patternTypes,    exclude: patternTypes,    max: [String, Number],  &#125;,  methods: &#123;    // 虚拟dom缓存    cacheVNode() &#123;      const &#123; cache, keys, vnodeToCache, keyToCache &#125; = this;      // 如果存在等待被缓存的vnode 就要缓存起来      if (vnodeToCache) &#123;        const &#123; tag, componentInstance, componentOptions &#125; = vnodeToCache;        cache[keyToCache] = &#123;          name: getComponentName(componentOptions),          tag,          componentInstance,        &#125;;        // 推vnode的key进入缓存组        keys.push(keyToCache);        // 如果缓存组件有最大数量限制的情况下 并且超大最大缓存数量限制，那么就删除缓存队列的第一项        // pruneCacheEntry 判断了当前的缓存队列的第一项是 如果跟新进来的最新vnode是否一致，        // 不一致的情况下就直接卸载当前第一项的实例，一致就保存不进行卸载进行复用操作        if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) &#123;          pruneCacheEntry(cache, keys[0], keys, this._vnode);        &#125;        this.vnodeToCache = null;      &#125;    &#125;,  &#125;,  created() &#123;    // 存储所有组件    this.cache = Object.create(null);    // 存储所有组件的cid值 源码里面是逐步递增的    this.keys = [];  &#125;,  destroyed() &#123;    // 卸载时删除所有缓存的组件实例    for (const key in this.cache) &#123;      pruneCacheEntry(this.cache, key, this.keys);    &#125;  &#125;,  mounted() &#123;    // 开始缓存当前实例    this.cacheVNode();    // 监听include和exclude队列，去除里面不匹配的的组件    this.$watch(&quot;include&quot;, (val) =&gt; &#123;      pruneCache(this, (name) =&gt; matches(val, name));    &#125;);    this.$watch(&quot;exclude&quot;, (val) =&gt; &#123;      pruneCache(this, (name) =&gt; !matches(val, name));    &#125;);  &#125;,  updated() &#123;    // 更新的时候同步更新当前vnode    this.cacheVNode();  &#125;,  render() &#123;    const slot = this.$slots.default;    const vnode: VNode = getFirstComponentChild(slot);    const componentOptions: ?VNodeComponentOptions =      vnode &amp;&amp; vnode.componentOptions;    // 如果存在组件实例    if (componentOptions) &#123;      // check pattern      const name: ?string = getComponentName(componentOptions);      const &#123; include, exclude &#125; = this;      // 如果不缓存的列表有当前vnode或者缓存列表没有当前vnode 那么就直接返回该节点      if (        (include &amp;&amp; (!name || !matches(include, name))) ||        (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))      ) &#123;        return vnode;      &#125;      // 到这里就说明当前组件是需要缓存的      const &#123; cache, keys &#125; = this;      const key: ?string =        vnode.key == null          ? componentOptions.Ctor.cid +            (componentOptions.tag ? `::$&#123;componentOptions.tag&#125;` : &quot;&quot;)          : vnode.key;      // 如果当前组件被缓存过 那么就更新当前组件 把组件推到缓存队列key的最后边，      // 这样就能总是获取到最新的更新项 LRU算法      if (cache[key]) &#123;        // 复用缓存        vnode.componentInstance = cache[key].componentInstance;        remove(keys, key);        keys.push(key);      &#125; else &#123;        this.vnodeToCache = vnode;        this.keyToCache = key;      &#125;      vnode.data.keepAlive = true;    &#125;    return vnode || (slot &amp;&amp; slot[0]);  &#125;,&#125;;\n\n说说 LRU 缓存淘汰算法LRU 算法，即最近最久未使用，是一种非常常见的缓存淘汰算法。算法的设计原则： 如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。\n下面是我自己画的 keep-alive 缓存淘汰算法的流程示意图例，辅助查看\n\n","slug":"Vue2.6系列源码解析之Keep-Alive组件的缓存逻辑2022-02-03","date":"2022-02-02T16:00:00.000Z","categories_index":"Vue,总结,Vue源码","tags_index":"Vue","author_index":"May"},{"id":"d36c9246f4e0462addbf95d33343891c","title":"Vue.2.6源码分析之事件挂载和双向绑定原理","content":"对于用 vue 的小伙伴来说，v-model 是 vue 开发过程中使用非常频繁的一个指令，它实现了数据的双向绑定。那么现在，我们就来探究一下发生双向绑定的过程是如何实现的\n设想一下绑定过程我们都知道，传入 data 的数据会被 Object.defineProperty 转化成 getter,setter进行监听，v-model 则是需要 input 框支持。当 input 输入时，view 层的数据也会随之动态改变，那么很明显是需要通过一个事件监听方法来触发的。当数据层被触发时，响应，那事件监听事件是在啥时候就开始挂载事件的呢?\n看看源码中事件怎么监听的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// src\\\\platforms\\\\web\\\\compiler\\\\directives\\\\model.jsfunction genDefaultModel(  el: ASTElement,  value: string,  modifiers: ?ASTModifiers): ?boolean &#123;  const type = el.attrsMap.type;  const &#123; lazy, number, trim &#125; = modifiers || &#123;&#125;;  // 没有携带lazy修饰符并且input类型伟range时就需要进行compsition检测  const needCompositionGuard = !lazy &amp;&amp; type !== &quot;range&quot;;  // 1.如果v-model携带lazy修饰符，那么就自动转成change事件  // change和input事件的区别: https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/change_event  // 2.如果不是滑块类型的input 那么就默认是input事件  const event = lazy ? &quot;change&quot; : type === &quot;range&quot; ? RANGE_TOKEN : &quot;input&quot;;  // 拼装执行语句  let valueExpression = &quot;$event.target.value&quot;;  if (trim) &#123;    valueExpression = `$event.target.value.trim()`;  &#125;  if (number) &#123;    valueExpression = `_n($&#123;valueExpression&#125;)`;  &#125;  // 调用genAssignmentCode语句重组  // 如果value有值，实际上调用的是this.$set方法  // if($event.target.composing)return;$set(day, key, $event.target.value)  let code = genAssignmentCode(value, valueExpression);  if (needCompositionGuard) &#123;    // composition事件 即输入法编辑器编辑时 就直接返回空    code = `if($event.target.composing)return;$&#123;code&#125;`;  &#125;  addProp(el, &quot;value&quot;, `($&#123;value&#125;)`);  // 增加监听事件  addHandler(el, event, code, null, true);  // 如果修饰符是trim或number那么应当立即强制更新  if (trim || number) &#123;    addHandler(el, &quot;blur&quot;, &quot;$forceUpdate()&quot;);  &#125;&#125;// src\\\\compiler\\\\helpers.js 塞进对象export function addHandler(  el: ASTElement,  name: string,  value: string,  modifiers: ?ASTModifiers,  important?: boolean,  warn?: ?Function,  range?: Range,  dynamic?: boolean) &#123;  modifiers = modifiers || emptyObject;  let events;  if (modifiers.native) &#123;    delete modifiers.native;    events = el.nativeEvents || (el.nativeEvents = &#123;&#125;);  &#125; else &#123;    events = el.events || (el.events = &#123;&#125;);  &#125;  // 普通input状态下 返回了&#123; value: value.trim()&#125;  const newHandler: any = rangeSetItem(&#123; value: value.trim(), dynamic &#125;, range);  if (modifiers !== emptyObject) &#123;    newHandler.modifiers = modifiers;  &#125;  // 对象塞入当前监听事件  const handlers = events[name];  if (Array.isArray(handlers)) &#123;    important ? handlers.unshift(newHandler) : handlers.push(newHandler);  &#125; else if (handlers) &#123;    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];  &#125; else &#123;    events[name] = newHandler;  &#125;  el.plain = false;&#125;// src/platforms/web/runtime/modules/events.js 生成vnode后增加事件监听function add(  name: string,  handler: Function,  capture: boolean,  passive: boolean) &#123;  if (useMicrotaskFix) &#123;    const attachedTimestamp = currentFlushTimestamp;    const original = handler;    handler = original._wrapper = function (e) &#123;      if (        e.target === e.currentTarget ||        e.timeStamp &gt;= attachedTimestamp ||        e.timeStamp &lt;= 0 ||        e.target.ownerDocument !== document      ) &#123;        return original.apply(this, arguments);      &#125;    &#125;;  &#125;  // 增加事件监听  target.addEventListener(    name,    handler,    supportsPassive ? &#123; capture, passive &#125; : capture  );&#125;\n\n由上面结合源码可知，在 compiler 编译模板之后生成 ast 语法，生成 ast 语法后会对当前 ast 调用 generate 方法进行一次格式化生成 render 函数，在 patch 阶段调用 updateDOMListeners 挂载当前监听方法，下面是我总结出来的事件编译挂载的流程图\n\n再来看看如何数据的更新监听要想实现数据监听，实时变化。vue2.6 中的策略是这样的，通过 Observer 使用 Object.defineProperty 遍历劫持 data 对象的所有属性，为每个属性生成一个 Dep 消息订阅器，并且在后续挂载中生成一个 Watcher 观察者实例，当第一次调用 render 函数解析模板时，会扫描到模板里面绑定的每个属性，从而触发当前属性的 getter，把当前 Watcher 加入到每个对象的 Dep 的 sub 列表里面，当属性更新之后会就会调用当前属性的 Dep，调用其 sub 里面每个 watcher 的 update 函数来实现更新\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202// 实现依赖收集器// src/core/observer/dep.jslet uid = 0;function remove(list, item) &#123;  const index = list.indexOf(item);  list.splice(index, 1);&#125;class Dep &#123;  constructor() &#123;    this.id = uid++;    this.sub = [];  &#125;  // 订阅所有依赖  depend() &#123;    console.log(this);    if (Dep.target) &#123;      console.log(Dep.target);      Dep.target.addDep(this);    &#125;  &#125;  addSub(watcher) &#123;    this.sub.push(watcher);  &#125;  removeSub(watcher) &#123;    remove(this.sub, watcher);  &#125;  notify() &#123;    console.log(this.sub);    this.sub.forEach((watcher) =&gt; watcher.update());  &#125;&#125;Dep.taget = null;const targetStack = [];// 赋值Dep.target主要是为了禁止某些getter依赖项触发到// Dep.target有值时才能触发depend方法function pushTarget(watcher) &#123;  Dep.target = watcher;  targetStack.push(watcher);&#125;function popTarget() &#123;  targetStack.pop();  Dep.target = targetStack[targetStack.length - 1];&#125;// 实现// src/core/observer/index.jsfunction observe(data) &#123;  let ob;  // 如果是对象，就对其进行监听  if (isObject(data)) &#123;    ob = new Observer(data);  &#125;  return ob;&#125;class Observer &#123;  constructor(data) &#123;    // 初始化依赖收集器    const dep = new Dep();    if (Array.isArray(data)) &#123;    &#125; else &#123;      this.walk(data);    &#125;  &#125;  // 监听内部的每一个key  walk(data) &#123;    const keyList = Object.keys(data);    for (let i = 0; i &lt; keyList.length; i++) &#123;      defineReactive(data, keyList[i]);    &#125;  &#125;&#125;function defineReactive(data, key, value) &#123;  const dep = new Dep();  // 没有传value时默认初始化value  if (arguments.length === 2) &#123;    value = data[key];  &#125;  // 遍历子项  let child = observe(data[key]);  // 对内部每个key进行一次代理  Object.defineProperty(data, key, &#123;    enumerable: true, // 可枚举    configurable: false, // 不能再define    get() &#123;      // 依赖收集器和watcher互相绑定      if (Dep.target) &#123;        dep.depend();        if (child) &#123;          child.dep.depend();        &#125;      &#125;      return value;    &#125;,    set(newValue) &#123;      // 新旧值不同的情况下就直接更新当前函数      if (newValue !== value) &#123;        value = newValue;        child = observe(data[key]);        dep.notify();      &#125;    &#125;,  &#125;);&#125;class Watcher &#123;  constructor(vm, expOrFn, cb, options) &#123;    this.id = ++id;    this.vm = vm;    this.expOrFn = expOrFn;    this.cb = cb;    this.lazy = options.lazy || false;    this.dirty = options.lazy || false;    // 新旧队列    this.newDepIdList = [];    this.depIdList = [];    this.newDepList = new Set();    this.depList = new Set();    console.log(expOrFn);    this.getter =      typeof this.expOrFn === &quot;function&quot;        ? this.expOrFn        : createExpOrFn(this.vm, this.expOrFn);    console.log(this.getter);    this.value = this.lazy ? &quot;&quot; : this.get();  &#125;  addDep(dep) &#123;    // 收集最新的依赖    if (!this.newDepIdList.includes(dep.id)) &#123;      this.newDepIdList.push(dep.id);      this.newDepList.add(dep);      // 如果队列里面没有      if (!this.depIdList.includes(dep.id)) &#123;        dep.addSub(this);      &#125;    &#125;    console.log(dep);  &#125;  // 单纯获取最新的值  get() &#123;    let value;    try &#123;      pushTarget(this);      value = this.getter.call(this.vm);    &#125; catch (e) &#123;    &#125; finally &#123;      this.cleanDepQueue();      popTarget();      console.log(&quot;清除了&quot;, value, this.getter);    &#125;    return value;  &#125;  // 更新  update() &#123;    if (this.lazy) &#123;      this.dirty = true;    &#125; else &#123;      queueWatcher(this);    &#125;  &#125;  run() &#123;    const value = this.get();    if (value !== this.value) &#123;      const oldValue = this.value;      this.cb.call(this.vm, value, oldValue);      this.value = value;    &#125;  &#125;  cleanDepQueue() &#123;    // 收集了新的依赖 如果新的依赖里面没有旧的 那就从旧的依赖里面去掉    // 试想一下 页面的绑定了一个值,并且设置了一个v-if指令，在下一次渲染之后，    // v-if=\\&quot;false\\&quot;不渲染了 但是上一个的依赖却已经被追踪了,这样就    // 会追踪额外的依赖项了，所以必须要清除    for (const dep of this.depList) &#123;      if (!this.newDepList.has(dep)) &#123;        dep.removeSub(this);      &#125;    &#125;    // 新的赋值给旧的  清空新依赖列表 新旧对比    let current = this.depList;    this.depList = this.newDepList;    this.newDepList = current;    this.newDepList.clear();    current = this.depIdList;    this.depIdList = this.newDepIdList;    this.newDepIdList = current;    this.newDepIdList.length = 0;  &#125;&#125;\n\n如果看不太懂的话可以参考我自己写的这一份链接 new Vue 双向绑定示例\n流程图展示下面是我自己绘制的流程图，可以通过这张图的调用顺序更简明地了解更新逻辑\n\n额外的一些注意点当前实例并没有关注到一些性能上的优化点，一个一个地说明会导致篇幅太长，相关的性能处理在上面的 github 示例链接里面，各位小伙伴有兴趣的话可以点击一下查看，帮我点个 star。\n另外可以看看我的其他文章，有一些内容会和当前内容有辅助功能，涉及到了优化相关。\n\nVue2.6 源码解析之数据更新队列和 nextTick 方法解析\nVue2.6 源码解析之 diff 算法更新过程及其相关问题\n\n","slug":"Vue.2.6源码分析之事件挂载和双向绑定原理2021-12-06","date":"2021-12-05T16:00:00.000Z","categories_index":"Vue,总结,Vue源码","tags_index":"Vue","author_index":"May"},{"id":"4d925ea8030231a2d81ae35ccafce2c7","title":"Vue2.6源码解析之数据更新队列和nextTick方法解析","content":"用了这么久的 Vue，我们都可以从官网上面知道，Vue 在更新 DOM 时是异步执行的,Vue 将开启一个队列，缓冲在同一事件循环中发生的所有数据变更,如果同一个 watcher 被多次触发，只会被推入到队列中一次，注: 首先要了解下 js 的事件循环和异步任务队列问题\n那么内部究竟是如何实现的呢，我们对源代码进行细纠，下面会省略一些不相关的代码。\n提供第一个 template 范例如果看了我的事件循环的文章，那么就可以知道任务队列中的异步任务分 task 任务和 microTask 微任务，每一次执行 task 的时候都会执行清空该 task 下的同级 microtask，理解这个原理对源码理解有巨大作用\n123456789101112131415161718192021222324252627282930313233343536373839404142&lt;div id=&quot;app&quot; @click=&quot;setData&quot;&gt;  &lt;span&gt;&#123;&#123; les &#125;&#125;/ &#123;&#123;time&#125;&#125;&lt;/span&gt;  &lt;uptime-day :day=&quot;day&quot; :les=&quot;les&quot; :time=&quot;time&quot; /&gt;&lt;/div&gt;&lt;script&gt;  const uptimeDay = &#123;    props: [&quot;time&quot;, &quot;les&quot;],    data() &#123;      return &#123;        isTrue: true,      &#125;;    &#125;,    methods: &#123;      handleClick() &#123;        this.isTrue = false;        this.$nextTick(() =&gt; &#123;          console.log(this.uptimeDay.innerText);        &#125;);      &#125;,    &#125;,    template: `&lt;div @click=&quot;handleClick&quot; ref=&quot;uptimeDay&quot;&gt;&#123;&#123; les &#125;&#125; &#123;&#123; time &#125;&#125;&lt;/div&gt;`,  &#125;;  var app = new Vue(&#123;    el: &quot;#app&quot;,    components: &#123;      uptimeDay,    &#125;,    data() &#123;      return &#123;        les: &quot;谢小谢&quot;,        time: &quot;now&quot;,      &#125;;    &#125;,    methods: &#123;      setData() &#123;        this.les = &quot;谢谢谢&quot;;        this.time = &quot;before&quot;;      &#125;,    &#125;,  &#125;);&lt;/script&gt;\n\n这里进行一步点击操作 调用 setData 函数\n初始渲染逻辑粗略解读\n\n\n\n\n\n\n\n\n看过源码的大概都知道，new Vue 之后的最后一步是调用 mountComponent 方法生成 Watcher 订阅者，watcher 传入了一个 updateComponent 函数（内部包含\\_update,render 方法）作为 getter,初始化时 Watcher 会调用其 getter 方法，进入内部逻辑调用 render 生成 vnode，调用\\_update 方法对 vnode 进行 patch 操作,具体请看下图。\n\n当前模板在\\_createElement 时，遇到子组件，判断是不是原生标签之后，会调用 Vue.extend 方法重头调用一次 Vue.prorotype.init 方法，所以当前会生成 2 个 Watcher。\n着重看一下 queueWatcher 执行过程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// src/core/observer/scheduler.js// 最大更新数量export const MAX_UPDATE_COUNT = 100const queue: Array&lt;Watcher&gt; = []const activatedChildren: Array&lt;Component&gt; = []let has: &#123; [key: number]: ?true &#125; = &#123;&#125;let circular: &#123; [key: number]: number &#125; = &#123;&#125;let waiting = falselet flushing = falselet index = 0// 重置队列和刷新状态function resetSchedulerState() &#123;  index = queue.length = activatedChildren.length = 0  has = &#123;&#125;  waiting = flushing = false&#125;export let currentFlushTimestamp = 0let getNow: () =&gt; number = Date.nowfunction flushSchedulerQueue() &#123;  // 设置当前的时间戳  currentFlushTimestamp = getNow()  flushing = true  let watcher, id  // 所有watcher根据id升序排列  // 疑问: 点解要排序？  // 回答: 1. 组件是从父级更新到子级，组件的渲染顺序是优于父级的，如果某个组件在父组件的观察程序运行期间被销毁，则可以跳过  queue.sort((a, b) =&gt; a.id - b.id)  // queue长度随时变化  for (index = 0; index &lt; queue.length; index++) &#123;    watcher = queue[index]    if (watcher.before) &#123;      watcher.before()    &#125;    id = watcher.id    has[id] = null    watcher.run()  &#125;  // 保留上次缓存过和更新后的状态实例 为下次触发生命周期做准备  const activatedQueue = activatedChildren.slice()  const updatedQueue = queue.slice()  // 清空状态  resetSchedulerState()  // 设置当前组件更activated状态  callActivatedHooks(activatedQueue)  // 设置当前组件为已更新状态  callUpdatedHooks(updatedQueue)&#125;// 触发生命周期function callUpdatedHooks(queue) &#123;  let i = queue.length  while (i--) &#123;    const watcher = queue[i]    const vm = watcher.vm    if (vm._watcher === watcher &amp;&amp; vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;      callHook(vm, &#x27;updated&#x27;)    &#125;  &#125;&#125;export function queueActivatedComponent(vm: Component) &#123;router-view)  vm._inactive = false  activatedChildren.push(vm)&#125;function callActivatedHooks(queue) &#123;  for (let i = 0; i &lt; queue.length; i++) &#123;    queue[i]._inactive = true    activateChildComponent(queue[i], true /* true */)  &#125;&#125;// 推watcher入栈export function queueWatcher(watcher: Watcher) &#123;  const id = watcher.id  if (has[id] == null) &#123;    has[id] = true    // 当前队列没有冲刷的时候    if (!flushing) &#123;      // 把当前watcher加入队列      queue.push(watcher)    &#125; else &#123;      // 已冲刷的和已经通过的就删除掉      let i = queue.length - 1      while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;        i--      &#125;      queue.splice(i + 1, 0, watcher)    &#125;    // 不是在等待中    if (!waiting) &#123;      nextTick(flushSchedulerQueue)    &#125;  &#125;&#125;\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// src/core/util/next-tick.jsexport let isUsingMicroTask = false;const callbacks = [];let pending = false;function flushCallbacks() &#123;  pending = false;  const copies = callbacks.slice(0);  callbacks.length = 0;  for (let i = 0; i &lt; copies.length; i++) &#123;    copies[i]();  &#125;&#125;// timeFunc根据环境兼容处理使用任务或者微任务let timerFunc;if (typeof Promise !== &quot;undefined&quot; &amp;&amp; isNative(Promise)) &#123;  const p = Promise.resolve();  timerFunc = () =&gt; &#123;    p.then(flushCallbacks);    if (isIOS) setTimeout(noop);  &#125;;  isUsingMicroTask = true;&#125; else if (  !isIE &amp;&amp;  typeof MutationObserver !== &quot;undefined&quot; &amp;&amp;  (isNative(MutationObserver) ||    MutationObserver.toString() === &quot;[object MutationObserverConstructor]&quot;)) &#123;  let counter = 1;  const observer = new MutationObserver(flushCallbacks);  const textNode = document.createTextNode(String(counter));  observer.observe(textNode, &#123;    characterData: true,  &#125;);  timerFunc = () =&gt; &#123;    counter = (counter + 1) % 2;    textNode.data = String(counter);  &#125;;  isUsingMicroTask = true;&#125; else if (typeof setImmediate !== &quot;undefined&quot; &amp;&amp; isNative(setImmediate)) &#123;  timerFunc = () =&gt; &#123;    setImmediate(flushCallbacks);  &#125;;&#125; else &#123;  // Fallback to setTimeout.  timerFunc = () =&gt; &#123;    setTimeout(flushCallbacks, 0);  &#125;;&#125;// 主处理函数export function nextTick(cb?: Function, ctx?: Object) &#123;  let _resolve;  // 入栈  callbacks.push(() =&gt; &#123;    if (cb) &#123;      try &#123;        cb.call(ctx);      &#125; catch (e) &#123;        handleError(e, ctx, &quot;nextTick&quot;);      &#125;    &#125; else if (_resolve) &#123;      _resolve(ctx);    &#125;  &#125;);  // 非等待情况下  if (!pending) &#123;    pending = true;    timerFunc();  &#125;&#125;\n\ntemplate 范例解读\n根据入口遍历，根组件和子组件会生成两个 watcher 实例，从父到子我们成为 watcher1， watcher2\n由上面的 template 可知，根组件#app 和子组件 uptimeDay 都绑定了事件，点击 uptimeDay 组件时，子组件 handleClick 方法已经进入整体 task 队列，内部 isTrue 为 true 时 setter 触发，进入 queueWatcher(watcher2),has[id]为 false,flushing 为 false 进入推入 queue 队列，调用 nextTick(flushSchedulerQueue: 简称该方法为 Fn1) ，nextTick 入栈后 callBack 推入 f1，默认 pending 为 false，调用 timeFunc，此时该函数进入 handleClick 这个 task 下的微任务队列里面，pending 变 true。\n随后，下方又调用了 this.$nextTick(() &#x3D;&gt; { console.log(this.$refs.ss.innerText); 简称该方法为 Fn2 }), Fn2 进入 nextTick 之后发现 pending &#x3D; true，所以被合并进入 callBacks 更新，pending &#x3D; false 子组件 patch 更新完成 queueWatcher。 初始化 重点: 此时，props 传进来的值并没有更新影响到 dom，打印出来的对象是有滞后性的，必须打印普通类型的值才能正确显示\n接着，事件冒泡到父级，setData 触发进入另外一个 task 队列，接着更改了 les,time 的值。触发 les 的 setter 更新进入 queueWatcher(watcher1)。首先 has[id]为 null, flushing 为 false, watcher1 被推入 queue 队列调用 nextTick，nextTick 内部 pending 为 false，执行 timeFunc，推入微任务队列挂起。随后 time 的 setter 被触发，后进入 queueWatcher，发现 has[id]为 true，waiting 为 true, 不推入队列。重点: 此时，这里就是上文说的 watcher 被多次触发，只推入队列一次，接着 timeFunc 的微任务开始调用，进入 flushSchedulerQueue 完成更新\n\n结论\n同 watcher 内更新只更新一次，因为多个 data 改变时，第一次的 reRender 就可以拿到当前实例上的最新值了，无需耗费更多计算资源。\n如果外部组件修改，子组件没有绑定当前修改的属性，并且没有应用于 dom，那么也是不会更新到子组件的(这个得看一下 Observe 数据劫持和 patch 的过程才能了解)\nscheduler.js 中有一段代码是很值得玩味的\n\n123456789101112// src/core/observer/scheduler.js// queue长度随时变化for (index = 0; index &lt; queue.length; index++) &#123;  watcher = queue[index];  if (watcher.before) &#123;    watcher.before();  &#125;  id = watcher.id;  has[id] = null;  watcher.run();&#125;\n\n这里算是对上面第 4 步的补充，当根组件的实例更新后，子组件也会更新重新进入 queueWatcher，watcher2 会被推入 queue 队列，此时循环体内的 queue 长度增加, 会一层一层往下调用子组件的 watcher 的 run 方法不断地重新 render 来进行 patch 操作，直到没有子组件为止(为什么？因为 vnode 为组件类型时没有 children，无法 patch，必须得重新 render 解析组件)\n","slug":"Vue2.6源码解析之数据更新队列和nextTick方法解析2021-11-24","date":"2021-11-23T16:00:00.000Z","categories_index":"Vue,总结,Vue源码","tags_index":"Vue","author_index":"May"},{"id":"d02145c722134b6141381c5add87923b","title":"服务器之正向代理和反向代理","content":"最近公司商家入驻准备上线，和运维在服务器代理这边折腾了不少时间，现在重新归纳一下正向代理和反向代理的相关概念和区别\n正向代理简述：正向代理服务器作接受来自客户端的请求，请求源服务器，把原服务器返回的内容响应给客户端\n注意：(此时源服务器并不知道客户端是谁)\n\n正向代理的应用&#x2F;使用原因：\n\n网址被墙，就可以在外网架设一个服务器作为中间服务器进行代理转发\n隐藏自身的浏览行为\n\n反向代理简述: 同正向代理一样，但是客户端并不知道实际访问的源服务器是谁，因为源服务器实际上可能会有多个，所以实际上像访问谷歌这种网页，都是要经过一层反向代理的服务器\n\n反向代理的应用&#x2F;使用原因：\n\n基于安全原因，不想直接暴露源服务器地址，就可以使用一个反向代理服务器，连接内外网，将反向代理服务器层作为类防火墙功能，进行安全校验。\n服务器负载均衡，访问一个资源时，根据源服务器的具体工作情况，分发到合适的服务器之中)\n\n反向代理和正向代理的区别\n\n\n\n\n\n\n\n\n正向代理服务器只对客户端负责，即隐藏用户\n\n\n\n\n\n\n\n\n\n反向代理服务器只对自己所代理的服务器负责，即隐藏源服务器\nVue 框架的开发时反向代理服务器路径设置及其区别12345678910// 请求地址 /api/blog/tags&#x27;/api&#x27; : &#123;target: &#x27;http://127.0.0.1:7001&#x27;,  pathRewrite: &#123;    &#x27;^/api&#x27;: &#x27;/blog&#x27; // 重写了url 相当于请求 http://127.0.0.1:7001/blog/blog/tags    &#x27;^/api&#x27;: &#x27;&#x27; // 重写了url 相当于请求 http://127.0.0.1:7001/blog/tags    &#x27;&#x27;: &#x27;&#x27; // 重写了url 相当于请求 http://127.0.0.1:7001/api/blog/tags  &#125;&#125;\n","slug":"服务器之正向代理和反向代理","date":"2021-07-27T16:00:00.000Z","categories_index":"总结","tags_index":"http","author_index":"May"},{"id":"977046a105528b08c6104c9e8e95e023","title":"HTTP缓存机制记录","content":"http 缓存机制很容易就忘记了 这里大概记录一下\n简单概括http 缓存分为强缓存(Cache-Control &gt; Expires),协商缓存(Etag &#x2F; If-None-Match &gt; Last-Modified &#x2F; If-Modified-Since)强缓存和协商缓存的区别&gt; 强缓存命中的情况下不和服务器做交互，协商缓存不管有没有命中都会和服务器做交互\n第一次请求\n浏览器发起 http 请求到服务器。\nhttp 请求通过浏览器缓存，浏览器缓存没有发现该请求的缓存标识和缓存结果，会直接放行，让 http 请求直接请求到服务器。\n服务器返回请求结果和缓存规则给浏览器\n浏览器将请求结果和缓存标识存入浏览器缓存中，作为下一次请求的标识\n\n第二次请求命中强缓存的情况\nExpires 该字段作为缓存标志， 如果客户端的时间小于 Expires 的值时，就直接使用缓存结果，但是这只是存在于 HTTP&#x2F;1.0 中，现今大部分已经被 Cache-Control 所替代\nCache-Control HTTP1.1 所使用的标识，该字段有以下几种属性\npublic：所有内容都将被缓存（客户端和代理服务器都可缓存）\nprivate：所有内容只有客户端可以缓存，Cache-Control 的默认取值\nno-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定\nno-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存\nmax-age&#x3D;xxx (xxx is numeric)：缓存内容将在 xxx 秒后失效\n\n第二次请求\n强缓存未命中，协商缓存命中的情况当协商缓存命中时，服务器返回 304 状态码表示该资源没有更新协商缓存字段有 Last-Modified &#x2F; If-Modified-Since 和 Etag &#x2F; If-None-Match，其中 Etag &#x2F; If-None-Match 的优先级比 Last-Modified &#x2F; If-Modified-Since 高。\nIf-None-Match&#x2F;Etag &#x3D;&gt; 客户端再次发起该请求时，携带上次请求返回的唯一标识 Etag 值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有 If-None-Match，则会根据 If-None-Match 的字段值与该资源在服务器的 Etag 值做对比，一致则返回 304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，返回 200\nLast-Modified&#x2F;If-Modified-Since &#x3D;&gt; 则是客户端再次发起该请求时，携带上次请求返回的 Last-Modified 值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有 If-Modified-Since 字段，则会根据 If-Modified-Since 的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于 If-Modified-Since 的字段值，则重新返回资源，状态码为 200；否则则返回 304，代表资源无更新，可继续使用缓存文件\n\n","slug":"HTTP缓存机制记录","date":"2019-12-03T16:00:00.000Z","categories_index":"http,总结","tags_index":"http","author_index":"May"},{"id":"c56ee70c55fbd1ff18b7573952b52a52","title":"CSS多行溢出处理","content":"前言之前做过的布局文字溢出效果 一段时间不用之后就老是忘记 今天记录下来\n单行溢出123overflow: hidden;text-overflow: ellipsis;white-space: nowrap;\n\n多行溢出(webkit)1234overflow: hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 2; // 在第几行处省略-webkit-box-orient: vertical;\n","slug":"CSS多行溢出处理","date":"2019-10-02T16:00:00.000Z","categories_index":"CSS样式","tags_index":"CSS,SCSS","author_index":"May"}]